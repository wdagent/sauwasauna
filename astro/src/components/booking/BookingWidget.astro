---
/**
 * BookingWidget - Sistema de reservas completo
 * WDA-901: Widget de reservas con calendario, slots y formulario
 *
 * Flujo:
 * 1. Mostrar calendario con fechas disponibles
 * 2. Al seleccionar fecha, mostrar slots de tiempo
 * 3. Al seleccionar slot, mostrar formulario
 * 4. Submit crea reserva y muestra confirmación
 *
 * Pattern: SSG + Client-side fetching (same as BlogScrollCards.astro)
 */

import { getLegalUrl } from '../../lib/wordpress/legal-slugs.js';
import DiscountCodeInput from './DiscountCodeInput.astro';

export interface Props {
  sessionId: number;
  locale?: 'es' | 'ca' | 'en' | 'fr';
  class?: string;
}

const { sessionId, locale = 'es', class: className = '' } = Astro.props;

// Translations for all supported languages
const translations = {
  es: {
    // Steps
    selectDate: 'Selecciona una fecha',
    selectTime: 'Elige un horario',
    yourDetails: 'Datos del comprador',
    confirmation: 'Reserva confirmada',
    // Calendar
    prevMonth: 'Mes anterior',
    nextMonth: 'Mes siguiente',
    months: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
    weekdays: ['Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb', 'Dom'],
    // Slots
    available: 'disponibles',
    spots: 'plazas',
    spot: 'plaza',
    full: 'Completo',
    closed: 'Cerrado',
    changeDate: 'Cambiar fecha',
    // Form
    name: 'Nombre completo',
    email: 'Correo electrónico',
    phone: 'Teléfono (opcional)',
    attendees: 'Número de asistentes',
    notes: 'Notas adicionales (opcional)',
    gdprLabel: 'He leído y acepto la',
    privacyLink: 'política de privacidad',
    privacyUrl: getLegalUrl('POLITICA_PRIVACIDAD', 'es'),
    termsLabel: 'He leído y acepto las',
    termsLink: 'condiciones de seguridad y contratación',
    termsUrl: getLegalUrl('CONDICIONES_CONTRATACION', 'es'),
    termsRequired: 'Debes aceptar las condiciones de contratación',
    confirm: 'Confirmar reserva',
    changeSlot: 'Cambiar horario',
    // WDA-909: Multi-attendee
    attendeeData: 'Datos de los asistentes',
    attendeeName: 'Nombre completo',
    attendeeEmail: 'Email (opcional)',
    buyerName: 'Nombre completo',
    buyerEmail: 'Email',
    addAttendee: 'Añadir asistente',
    removeAttendee: 'Eliminar',
    mainContact: 'Contacto principal',
    // Validation
    nameRequired: 'El nombre es obligatorio',
    emailRequired: 'El email es obligatorio',
    emailInvalid: 'El email no es válido',
    phoneInvalid: 'El teléfono no es válido',
    attendeesRequired: 'Indica el número de asistentes',
    attendeesMax: 'Máximo {max} asistentes',
    privacyRequired: 'Debes aceptar la política de privacidad',
    // States
    loading: 'Cargando...',
    loadingDates: 'Cargando fechas disponibles...',
    loadingSlots: 'Cargando horarios...',
    submitting: 'Procesando reserva...',
    noSlots: 'No hay horarios disponibles para esta fecha',
    noDates: 'No hay fechas disponibles en este período',
    // Confirmation
    successTitle: '¡Reserva confirmada!',
    successMessage: 'Recibirás un email de confirmación en breve.',
    bookingNumber: 'Número de reserva',
    bookingDate: 'Fecha',
    bookingTime: 'Hora',
    bookingAttendees: 'Asistentes',
    newBooking: 'Nueva reserva',
    // Errors
    errorTitle: 'Error al procesar la reserva',
    errorGeneric: 'Ha ocurrido un error. Por favor, inténtalo de nuevo.',
    errorSpotsLimit: 'Solo quedan {n} plazas disponibles',
    errorSlotFull: 'Este horario ya está completo',
    errorSlotClosed: 'Este horario ya no está disponible',
    errorInvalidDate: 'La fecha seleccionada no es válida',
    errorSessionExpired: 'Tu sesión ha expirado. Por favor, recarga la página.',
    errorEmailRequired: 'El email del asistente {n} es obligatorio',
    errorRateLimit: 'Demasiados intentos. Por favor, espera unos minutos.',
    tryAgain: 'Intentar de nuevo',
    // WDA-920: UX Capacidad Limitada
    spotsRemaining: 'Solo quedan {n} plazas para este horario',
    capacityReached: 'Capacidad máxima alcanzada ({current}/{max} plazas)',
    spotsAvailableText: '{n} plazas disponibles',
    // WDA-921: Rate Limiting
    rateLimitMessage: 'Demasiados intentos. Intenta de nuevo en {time}',
    // WDA-922: A11Y
    a11y: {
      prevMonth: 'Mes anterior',
      nextMonth: 'Mes siguiente',
      attendeeAdded: 'Asistente {n} añadido',
      attendeeRemoved: 'Asistente eliminado',
      stepLabel: 'Paso',
    },
    // WDA-974: Differentiated booking flows
    packInfo: 'Este pack incluye entrada para {n} personas',
    voucherInfo: 'Este bono incluye {n} entradas válidas por {m} meses',
    privateInfo: 'Sesión privada - Uso exclusivo de la sauna',
    voucherCodesTitle: 'Tus códigos de bono',
    voucherCodesNote: 'Guarda estos códigos. Los recibirás también por email.',
    voucherSuccessTitle: '¡Compra de bono confirmada!',
    voucherSuccessMessage: 'Recibirás un email con tus códigos de bono.',
    groupSize: '¿Cuántas personas vendrán?',
    groupSizeOptional: '(opcional, solo informativo)',
    // WDA-1002: Pack slot capacity
    insufficientForPack: 'Mín. {n} plazas requeridas',
    noPackSlots: 'No hay horarios con {n} plazas disponibles',
    // WDA-1004: Private sessions
    privateExclusive: 'Uso exclusivo',
    noPrivateSlots: 'No hay horarios con disponibilidad exclusiva para esta fecha',
    // WDA-1033: Gift sessions
    giftInfo: 'Este regalo incluye entrada para {n} personas',
    giftSuccessTitle: '¡Compra de regalo confirmada!',
    giftSuccessMessage: 'El destinatario recibirá un email con el código del regalo.',
    giftCodeTitle: 'Código del regalo',
    giftCodeNote: 'Guarda este código. El destinatario lo recibirá por email.',
    giftRecipientSection: 'Datos del destinatario',
    giftRecipientName: 'Nombre del destinatario',
    giftRecipientEmail: 'Email del destinatario',
    giftMessage: 'Mensaje personalizado (opcional)',
    giftMessagePlaceholder: 'Escribe un mensaje para el destinatario...',
    giftDeliveryDate: 'Fecha de entrega (opcional)',
    giftDeliveryNow: 'Enviar ahora',
    giftDeliveryScheduled: 'Programar envío',
    giftDeliveryNoSend: 'No enviar (entrega en mano)',
    giftDeliveryTime: 'Hora de envío',
    giftNoSendMessage: 'El código de regalo te llegará a ti. Podrás entregarlo personalmente.',
    giftRecipientNameRequired: 'El nombre del destinatario es obligatorio',
    giftRecipientEmailRequired: 'El email del destinatario es obligatorio',
    // WDA-1023: Discount codes
    discountSection: '¿Tienes un código de descuento?',
    originalPrice: 'Precio base',
    discountApplied: 'Descuento aplicado',
    totalPrice: 'Total a pagar',
  },
  ca: {
    selectDate: 'Selecciona una data',
    selectTime: 'Tria un horari',
    yourDetails: 'Dades del comprador',
    confirmation: 'Reserva confirmada',
    prevMonth: 'Mes anterior',
    nextMonth: 'Mes següent',
    months: ['Gener', 'Febrer', 'Març', 'Abril', 'Maig', 'Juny', 'Juliol', 'Agost', 'Setembre', 'Octubre', 'Novembre', 'Desembre'],
    weekdays: ['Dll', 'Dmt', 'Dmc', 'Dij', 'Dve', 'Dis', 'Dge'],
    available: 'disponibles',
    spots: 'places',
    spot: 'plaça',
    full: 'Complet',
    closed: 'Tancat',
    changeDate: 'Canviar data',
    name: 'Nom complet',
    email: 'Correu electrònic',
    phone: 'Telèfon (opcional)',
    attendees: 'Nombre d\'assistents',
    notes: 'Notes addicionals (opcional)',
    gdprLabel: 'He llegit i accepto la',
    privacyLink: 'política de privacitat',
    privacyUrl: getLegalUrl('POLITICA_PRIVACIDAD', 'ca'),
    termsLabel: 'He llegit i accepto les',
    termsLink: 'condicions de seguretat i contractació',
    termsUrl: getLegalUrl('CONDICIONES_CONTRATACION', 'ca'),
    termsRequired: 'Has d\'acceptar les condicions de contractació',
    confirm: 'Confirmar reserva',
    changeSlot: 'Canviar horari',
    attendeeData: 'Dades dels assistents',
    attendeeName: 'Nom complet',
    attendeeEmail: 'Email (opcional)',
    buyerName: 'Nom complet',
    buyerEmail: 'Email',
    addAttendee: 'Afegir assistent',
    removeAttendee: 'Eliminar',
    mainContact: 'Contacte principal',
    nameRequired: 'El nom és obligatori',
    emailRequired: 'L\'email és obligatori',
    emailInvalid: 'L\'email no és vàlid',
    phoneInvalid: 'El telèfon no és vàlid',
    attendeesRequired: 'Indica el nombre d\'assistents',
    attendeesMax: 'Màxim {max} assistents',
    privacyRequired: 'Has d\'acceptar la política de privacitat',
    loading: 'Carregant...',
    loadingDates: 'Carregant dates disponibles...',
    loadingSlots: 'Carregant horaris...',
    submitting: 'Processant reserva...',
    noSlots: 'No hi ha horaris disponibles per aquesta data',
    noDates: 'No hi ha dates disponibles en aquest període',
    successTitle: 'Reserva confirmada!',
    successMessage: 'Rebràs un email de confirmació aviat.',
    bookingNumber: 'Número de reserva',
    bookingDate: 'Data',
    bookingTime: 'Hora',
    bookingAttendees: 'Assistents',
    newBooking: 'Nova reserva',
    errorTitle: 'Error en processar la reserva',
    errorGeneric: 'S\'ha produït un error. Si us plau, torna-ho a intentar.',
    errorSpotsLimit: 'Només queden {n} places disponibles',
    errorSlotFull: 'Aquest horari ja està complet',
    errorSlotClosed: 'Aquest horari ja no està disponible',
    errorInvalidDate: 'La data seleccionada no és vàlida',
    errorSessionExpired: 'La teva sessió ha expirat. Si us plau, recarrega la pàgina.',
    errorEmailRequired: 'L\'email de l\'assistent {n} és obligatori',
    errorRateLimit: 'Massa intents. Si us plau, espera uns minuts.',
    tryAgain: 'Tornar a intentar',
    // WDA-920: UX Capacidad Limitada
    spotsRemaining: 'Només queden {n} places per a aquest horari',
    capacityReached: 'Capacitat màxima assolida ({current}/{max} places)',
    spotsAvailableText: '{n} places disponibles',
    // WDA-921: Rate Limiting
    rateLimitMessage: 'Massa intents. Torna a intentar-ho en {time}',
    // WDA-922: A11Y
    a11y: {
      prevMonth: 'Mes anterior',
      nextMonth: 'Mes següent',
      attendeeAdded: 'Assistent {n} afegit',
      attendeeRemoved: 'Assistent eliminat',
      stepLabel: 'Pas',
    },
    // WDA-974: Differentiated booking flows
    packInfo: 'Aquest pack inclou entrada per a {n} persones',
    voucherInfo: 'Aquest bo inclou {n} entrades vàlides per {m} mesos',
    privateInfo: 'Sessió privada - Ús exclusiu de la sauna',
    voucherCodesTitle: 'Els teus codis de bo',
    voucherCodesNote: 'Guarda aquests codis. Els rebràs també per email.',
    voucherSuccessTitle: 'Compra de bo confirmada!',
    voucherSuccessMessage: 'Rebràs un email amb els teus codis de bo.',
    groupSize: 'Quantes persones vindran?',
    groupSizeOptional: '(opcional, només informatiu)',
    // WDA-1002: Pack slot capacity
    insufficientForPack: 'Mín. {n} places requerides',
    noPackSlots: 'No hi ha horaris amb {n} places disponibles',
    // WDA-1004: Private sessions
    privateExclusive: 'Ús exclusiu',
    noPrivateSlots: 'No hi ha horaris amb disponibilitat exclusiva per aquesta data',
    // WDA-1033: Gift sessions
    giftInfo: 'Aquest regal inclou entrada per a {n} persones',
    giftSuccessTitle: 'Compra de regal confirmada!',
    giftSuccessMessage: 'El destinatari rebrà un email amb el codi del regal.',
    giftCodeTitle: 'Codi del regal',
    giftCodeNote: 'Guarda aquest codi. El destinatari el rebrà per email.',
    giftRecipientSection: 'Dades del destinatari',
    giftRecipientName: 'Nom del destinatari',
    giftRecipientEmail: 'Email del destinatari',
    giftMessage: 'Missatge personalitzat (opcional)',
    giftMessagePlaceholder: 'Escriu un missatge per al destinatari...',
    giftDeliveryDate: 'Data d\'entrega (opcional)',
    giftDeliveryNow: 'Enviar ara',
    giftDeliveryScheduled: 'Programar enviament',
    giftDeliveryNoSend: 'No enviar (entrega en mà)',
    giftDeliveryTime: 'Hora d\'enviament',
    giftNoSendMessage: 'El codi de regal t\'arribarà a tu. Podràs entregar-lo personalment.',
    giftRecipientNameRequired: 'El nom del destinatari és obligatori',
    giftRecipientEmailRequired: 'L\'email del destinatari és obligatori',
    // WDA-1023: Discount codes
    discountSection: 'Tens un codi de descompte?',
    originalPrice: 'Preu base',
    discountApplied: 'Descompte aplicat',
    totalPrice: 'Total a pagar',
  },
  en: {
    selectDate: 'Select a date',
    selectTime: 'Choose a time',
    yourDetails: 'Buyer details',
    confirmation: 'Booking confirmed',
    prevMonth: 'Previous month',
    nextMonth: 'Next month',
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    weekdays: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
    available: 'available',
    spots: 'spots',
    spot: 'spot',
    full: 'Full',
    closed: 'Closed',
    changeDate: 'Change date',
    name: 'Full name',
    email: 'Email address',
    phone: 'Phone (optional)',
    attendees: 'Number of attendees',
    notes: 'Additional notes (optional)',
    gdprLabel: 'I have read and accept the',
    privacyLink: 'privacy policy',
    privacyUrl: getLegalUrl('POLITICA_PRIVACIDAD', 'en'),
    termsLabel: 'I have read and accept the',
    termsLink: 'safety and booking terms',
    termsUrl: getLegalUrl('CONDICIONES_CONTRATACION', 'en'),
    termsRequired: 'You must accept the booking terms',
    confirm: 'Confirm booking',
    changeSlot: 'Change time',
    attendeeData: 'Attendee details',
    attendeeName: 'Full name',
    attendeeEmail: 'Email (optional)',
    buyerName: 'Full name',
    buyerEmail: 'Email',
    addAttendee: 'Add attendee',
    removeAttendee: 'Remove',
    mainContact: 'Main contact',
    nameRequired: 'Name is required',
    emailRequired: 'Email is required',
    emailInvalid: 'Email is not valid',
    phoneInvalid: 'Phone is not valid',
    attendeesRequired: 'Please indicate number of attendees',
    attendeesMax: 'Maximum {max} attendees',
    privacyRequired: 'You must accept the privacy policy',
    loading: 'Loading...',
    loadingDates: 'Loading available dates...',
    loadingSlots: 'Loading time slots...',
    submitting: 'Processing booking...',
    noSlots: 'No time slots available for this date',
    noDates: 'No dates available in this period',
    successTitle: 'Booking confirmed!',
    successMessage: 'You will receive a confirmation email shortly.',
    bookingNumber: 'Booking number',
    bookingDate: 'Date',
    bookingTime: 'Time',
    bookingAttendees: 'Attendees',
    newBooking: 'New booking',
    errorTitle: 'Error processing booking',
    errorGeneric: 'An error occurred. Please try again.',
    errorSpotsLimit: 'Only {n} spots available',
    errorSlotFull: 'This time slot is already full',
    errorSlotClosed: 'This time slot is no longer available',
    errorInvalidDate: 'The selected date is not valid',
    errorSessionExpired: 'Your session has expired. Please reload the page.',
    errorEmailRequired: 'Attendee {n} email is required',
    errorRateLimit: 'Too many attempts. Please wait a few minutes.',
    tryAgain: 'Try again',
    // WDA-920: UX Capacidad Limitada
    spotsRemaining: 'Only {n} spots remaining for this time',
    capacityReached: 'Maximum capacity reached ({current}/{max} spots)',
    spotsAvailableText: '{n} spots available',
    // WDA-921: Rate Limiting
    rateLimitMessage: 'Too many attempts. Try again in {time}',
    // WDA-922: A11Y
    a11y: {
      prevMonth: 'Previous month',
      nextMonth: 'Next month',
      attendeeAdded: 'Attendee {n} added',
      attendeeRemoved: 'Attendee removed',
      stepLabel: 'Step',
    },
    // WDA-974: Differentiated booking flows
    packInfo: 'This pack includes entry for {n} people',
    voucherInfo: 'This voucher includes {n} entries valid for {m} months',
    privateInfo: 'Private session - Exclusive use of the sauna',
    voucherCodesTitle: 'Your voucher codes',
    voucherCodesNote: 'Save these codes. You will also receive them by email.',
    voucherSuccessTitle: 'Voucher purchase confirmed!',
    voucherSuccessMessage: 'You will receive an email with your voucher codes.',
    groupSize: 'How many people will come?',
    groupSizeOptional: '(optional, informative only)',
    // WDA-1002: Pack slot capacity
    insufficientForPack: 'Min. {n} spots required',
    noPackSlots: 'No time slots with {n} spots available',
    // WDA-1004: Private sessions
    privateExclusive: 'Exclusive use',
    noPrivateSlots: 'No time slots with exclusive availability for this date',
    // WDA-1033: Gift sessions
    giftInfo: 'This gift includes entry for {n} people',
    giftSuccessTitle: 'Gift purchase confirmed!',
    giftSuccessMessage: 'The recipient will receive an email with the gift code.',
    giftCodeTitle: 'Gift code',
    giftCodeNote: 'Save this code. The recipient will receive it by email.',
    giftRecipientSection: 'Recipient details',
    giftRecipientName: 'Recipient name',
    giftRecipientEmail: 'Recipient email',
    giftMessage: 'Personal message (optional)',
    giftMessagePlaceholder: 'Write a message for the recipient...',
    giftDeliveryDate: 'Delivery date (optional)',
    giftDeliveryNow: 'Send now',
    giftDeliveryScheduled: 'Schedule delivery',
    giftDeliveryNoSend: 'Don\'t send (hand delivery)',
    giftDeliveryTime: 'Delivery time',
    giftNoSendMessage: 'The gift code will be sent to you. You can deliver it personally.',
    giftRecipientNameRequired: 'Recipient name is required',
    giftRecipientEmailRequired: 'Recipient email is required',
    // WDA-1023: Discount codes
    discountSection: 'Do you have a discount code?',
    originalPrice: 'Base price',
    discountApplied: 'Discount applied',
    totalPrice: 'Total to pay',
  },
  fr: {
    selectDate: 'Sélectionnez une date',
    selectTime: 'Choisissez un horaire',
    yourDetails: 'Données de l\'acheteur',
    confirmation: 'Réservation confirmée',
    prevMonth: 'Mois précédent',
    nextMonth: 'Mois suivant',
    months: ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'],
    weekdays: ['Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam', 'Dim'],
    available: 'disponibles',
    spots: 'places',
    spot: 'place',
    full: 'Complet',
    closed: 'Fermé',
    changeDate: 'Changer la date',
    name: 'Nom complet',
    email: 'Adresse email',
    phone: 'Téléphone (optionnel)',
    attendees: 'Nombre de participants',
    notes: 'Notes supplémentaires (optionnel)',
    gdprLabel: 'J\'ai lu et j\'accepte la',
    privacyLink: 'politique de confidentialité',
    privacyUrl: getLegalUrl('POLITICA_PRIVACIDAD', 'fr'),
    termsLabel: 'J\'ai lu et j\'accepte les',
    termsLink: 'conditions de sécurité et de réservation',
    termsUrl: getLegalUrl('CONDICIONES_CONTRATACION', 'fr'),
    termsRequired: 'Vous devez accepter les conditions de réservation',
    confirm: 'Confirmer la réservation',
    changeSlot: 'Changer l\'horaire',
    attendeeData: 'Détails des participants',
    attendeeName: 'Nom complet',
    attendeeEmail: 'Email (optionnel)',
    buyerName: 'Nom complet',
    buyerEmail: 'Email',
    addAttendee: 'Ajouter un participant',
    removeAttendee: 'Supprimer',
    mainContact: 'Contact principal',
    nameRequired: 'Le nom est obligatoire',
    emailRequired: 'L\'email est obligatoire',
    emailInvalid: 'L\'email n\'est pas valide',
    phoneInvalid: 'Le téléphone n\'est pas valide',
    attendeesRequired: 'Veuillez indiquer le nombre de participants',
    attendeesMax: 'Maximum {max} participants',
    privacyRequired: 'Vous devez accepter la politique de confidentialité',
    loading: 'Chargement...',
    loadingDates: 'Chargement des dates disponibles...',
    loadingSlots: 'Chargement des horaires...',
    submitting: 'Traitement de la réservation...',
    noSlots: 'Aucun horaire disponible pour cette date',
    noDates: 'Aucune date disponible dans cette période',
    successTitle: 'Réservation confirmée!',
    successMessage: 'Vous recevrez un email de confirmation sous peu.',
    bookingNumber: 'Numéro de réservation',
    bookingDate: 'Date',
    bookingTime: 'Heure',
    bookingAttendees: 'Participants',
    newBooking: 'Nouvelle réservation',
    errorTitle: 'Erreur lors du traitement de la réservation',
    errorGeneric: 'Une erreur s\'est produite. Veuillez réessayer.',
    errorSpotsLimit: 'Seulement {n} places disponibles',
    errorSlotFull: 'Ce créneau est déjà complet',
    errorSlotClosed: 'Ce créneau n\'est plus disponible',
    errorInvalidDate: 'La date sélectionnée n\'est pas valide',
    errorSessionExpired: 'Votre session a expiré. Veuillez recharger la page.',
    errorEmailRequired: 'L\'email du participant {n} est requis',
    errorRateLimit: 'Trop de tentatives. Veuillez attendre quelques minutes.',
    tryAgain: 'Réessayer',
    // WDA-920: UX Capacidad Limitada
    spotsRemaining: 'Seulement {n} places restantes pour cet horaire',
    capacityReached: 'Capacité maximale atteinte ({current}/{max} places)',
    spotsAvailableText: '{n} places disponibles',
    // WDA-921: Rate Limiting
    rateLimitMessage: 'Trop de tentatives. Réessayez dans {time}',
    // WDA-922: A11Y
    a11y: {
      prevMonth: 'Mois précédent',
      nextMonth: 'Mois suivant',
      attendeeAdded: 'Participant {n} ajouté',
      attendeeRemoved: 'Participant supprimé',
      stepLabel: 'Étape',
    },
    // WDA-974: Differentiated booking flows
    packInfo: 'Ce pack comprend l\'entrée pour {n} personnes',
    voucherInfo: 'Ce bon comprend {n} entrées valables {m} mois',
    privateInfo: 'Séance privée - Usage exclusif du sauna',
    voucherCodesTitle: 'Vos codes de bon',
    voucherCodesNote: 'Conservez ces codes. Vous les recevrez également par email.',
    voucherSuccessTitle: 'Achat de bon confirmé !',
    voucherSuccessMessage: 'Vous recevrez un email avec vos codes de bon.',
    groupSize: 'Combien de personnes viendront?',
    groupSizeOptional: '(optionnel, informatif uniquement)',
    // WDA-1002: Pack slot capacity
    insufficientForPack: 'Min. {n} places requises',
    noPackSlots: 'Aucun horaire avec {n} places disponibles',
    // WDA-1004: Private sessions
    privateExclusive: 'Usage exclusif',
    noPrivateSlots: 'Aucun horaire avec disponibilité exclusive pour cette date',
    // WDA-1033: Gift sessions
    giftInfo: 'Ce cadeau comprend l\'entrée pour {n} personnes',
    giftSuccessTitle: 'Achat de cadeau confirmé !',
    giftSuccessMessage: 'Le destinataire recevra un email avec le code du cadeau.',
    giftCodeTitle: 'Code du cadeau',
    giftCodeNote: 'Conservez ce code. Le destinataire le recevra par email.',
    giftRecipientSection: 'Données du destinataire',
    giftRecipientName: 'Nom du destinataire',
    giftRecipientEmail: 'Email du destinataire',
    giftMessage: 'Message personnalisé (optionnel)',
    giftMessagePlaceholder: 'Écrivez un message pour le destinataire...',
    giftDeliveryDate: 'Date de livraison (optionnel)',
    giftDeliveryNow: 'Envoyer maintenant',
    giftDeliveryScheduled: 'Programmer l\'envoi',
    giftDeliveryNoSend: 'Ne pas envoyer (remise en main)',
    giftDeliveryTime: 'Heure d\'envoi',
    giftNoSendMessage: 'Le code cadeau vous sera envoyé. Vous pourrez le remettre personnellement.',
    giftRecipientNameRequired: 'Le nom du destinataire est obligatoire',
    giftRecipientEmailRequired: 'L\'email du destinataire est obligatoire',
    // WDA-1023: Discount codes
    discountSection: 'Avez-vous un code de réduction?',
    originalPrice: 'Prix de base',
    discountApplied: 'Réduction appliquée',
    totalPrice: 'Total à payer',
  },
};

const t = translations[locale];
const uniqueId = `booking-${sessionId}-${Date.now()}`;
---

<div
  class={`booking-widget ${className}`}
  data-session-id={sessionId}
  data-locale={locale}
  data-translations={JSON.stringify(t)}
  id={uniqueId}
>
  <!-- WDA-922: A11Y - Screen reader announcements -->
  <div
    id={`booking-announcements-${uniqueId}`}
    class="sr-only"
    aria-live="polite"
    aria-atomic="true"
  ></div>

  <!-- Progress Steps - WDA-909: Clickable para volver atrás -->
  <div class="booking-progress">
    <button type="button" class="progress-step active" data-step="calendar" data-step-index="0" aria-label={`${t.a11y.stepLabel} 1: ${t.selectDate}`} aria-current="step">
      <span class="step-number">1</span>
      <span class="step-label">{t.selectDate}</span>
    </button>
    <div class="progress-connector"></div>
    <button type="button" class="progress-step" data-step="slots" data-step-index="1" aria-label={`${t.a11y.stepLabel} 2: ${t.selectTime}`}>
      <span class="step-number">2</span>
      <span class="step-label">{t.selectTime}</span>
    </button>
    <div class="progress-connector"></div>
    <button type="button" class="progress-step" data-step="form" data-step-index="2" aria-label={`${t.a11y.stepLabel} 3: ${t.yourDetails}`}>
      <span class="step-number">3</span>
      <span class="step-label">{t.yourDetails}</span>
    </button>
    <div class="progress-connector"></div>
    <button type="button" class="progress-step" data-step="confirmation" data-step-index="3" disabled aria-label={`${t.a11y.stepLabel} 4: ${t.confirmation}`}>
      <span class="step-number">4</span>
      <span class="step-label">{t.confirmation}</span>
    </button>
  </div>

  <!-- WDA-974: Session type info banner (hidden by default, shown by JS) -->
  <div class="session-type-info hidden" role="status" data-session-type="">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="info-icon">
      <circle cx="12" cy="12" r="10"></circle>
      <line x1="12" y1="16" x2="12" y2="12"></line>
      <line x1="12" y1="8" x2="12.01" y2="8"></line>
    </svg>
    <span class="session-type-text"></span>
  </div>

  <!-- Step 1: Calendar -->
  <div class="booking-step active" data-step="calendar">
    <div class="step-header">
      <h3 class="step-title">{t.selectDate}</h3>
    </div>
    <div class="calendar-container">
      <!-- Calendar header with navigation -->
      <div class="calendar-header">
        <button type="button" class="calendar-nav prev-month" aria-label={t.a11y.prevMonth}>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
        </button>
        <span class="calendar-month-year"></span>
        <button type="button" class="calendar-nav next-month" aria-label={t.a11y.nextMonth}>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="9 18 15 12 9 6"></polyline>
          </svg>
        </button>
      </div>
      <!-- Weekday labels -->
      <div class="calendar-weekdays">
        {t.weekdays.map((day: string) => <span class="weekday">{day}</span>)}
      </div>
      <!-- Calendar grid (populated by JS) -->
      <div class="calendar-grid">
        <!-- Days will be rendered here -->
      </div>
      <!-- Loading state -->
      <div class="calendar-loading hidden">
        <div class="loading-spinner"></div>
        <span>{t.loadingDates}</span>
      </div>
      <!-- No dates message -->
      <div class="calendar-empty hidden">
        <p>{t.noDates}</p>
      </div>
    </div>
  </div>

  <!-- Step 2: Time Slots -->
  <div class="booking-step hidden" data-step="slots">
    <div class="step-header">
      <h3 class="step-title">{t.selectTime}</h3>
      <button type="button" class="back-button" data-action="back-to-calendar">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
        {t.changeDate}
      </button>
    </div>
    <div class="selected-date-display">
      <!-- Shows selected date -->
    </div>
    <div class="slots-container">
      <!-- Slots will be rendered here -->
    </div>
    <!-- Loading state -->
    <div class="slots-loading hidden">
      <div class="loading-spinner"></div>
      <span>{t.loadingSlots}</span>
    </div>
    <!-- No slots message -->
    <div class="slots-empty hidden">
      <p>{t.noSlots}</p>
    </div>
  </div>

  <!-- Step 3: Booking Form -->
  <div class="booking-step hidden" data-step="form">
    <div class="step-header">
      <h3 class="step-title">{t.yourDetails}</h3>
      <button type="button" class="back-button" data-action="back-to-slots">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
        {t.changeSlot}
      </button>
    </div>

    <!-- Selected slot summary -->
    <div class="selection-summary">
      <div class="summary-item">
        <span class="summary-label">{t.bookingDate}:</span>
        <span class="summary-value selected-date-text"></span>
      </div>
      <div class="summary-item">
        <span class="summary-label">{t.bookingTime}:</span>
        <span class="summary-value selected-slot-text"></span>
      </div>
    </div>

    <!-- WDA-920: Mensaje de capacidad limitada -->
    <div class="capacity-warning hidden" role="alert">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="12" y1="8" x2="12" y2="12"></line>
        <line x1="12" y1="16" x2="12.01" y2="16"></line>
      </svg>
      <span class="capacity-warning-text"></span>
    </div>

    <!-- WDA-920: Badge de capacidad del slot seleccionado -->
    <div class="slot-capacity-badge hidden">
      <span class="capacity-badge-text"></span>
    </div>

    <!-- WDA-921: Rate limit countdown message -->
    <div class="rate-limit-message hidden" role="alert" aria-live="polite">
      <!-- Mensaje dinámico del countdown -->
    </div>

    <form class="booking-form" novalidate>
      <!-- Name -->
      <div class="form-group">
        <label for={`name-${uniqueId}`} class="form-label">
          {t.name} <span class="required">*</span>
        </label>
        <input
          type="text"
          id={`name-${uniqueId}`}
          name="customer_name"
          required
          class="form-input"
          autocomplete="name"
        />
        <span class="form-error hidden" role="status" aria-live="polite">{t.nameRequired}</span>
      </div>

      <!-- Email -->
      <div class="form-group">
        <label for={`email-${uniqueId}`} class="form-label">
          {t.email} <span class="required">*</span>
        </label>
        <input
          type="email"
          id={`email-${uniqueId}`}
          name="customer_email"
          required
          class="form-input"
          autocomplete="email"
        />
        <span class="form-error hidden" role="status" aria-live="polite">{t.emailRequired}</span>
      </div>

      <!-- Phone -->
      <div class="form-group">
        <label for={`phone-${uniqueId}`} class="form-label">
          {t.phone}
        </label>
        <input
          type="tel"
          id={`phone-${uniqueId}`}
          name="customer_phone"
          class="form-input"
          autocomplete="tel"
        />
        <span class="form-error hidden" role="status" aria-live="polite">{t.phoneInvalid}</span>
      </div>

      <!-- WDA-1033: Gift Recipient Section (hidden by default, shown for gift purchases) -->
      <div class="gift-recipient-section hidden">
        <div class="gift-section-header">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="gift-icon">
            <polyline points="20 12 20 22 4 22 4 12"></polyline>
            <rect x="2" y="7" width="20" height="5"></rect>
            <line x1="12" y1="22" x2="12" y2="7"></line>
            <path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path>
            <path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>
          </svg>
          <span class="form-label">{t.giftRecipientSection} <span class="required">*</span></span>
        </div>
        <div class="gift-recipient-fields">
          <!-- Recipient Name -->
          <div class="form-group">
            <label for={`recipient-name-${uniqueId}`} class="form-label">
              {t.giftRecipientName} <span class="required">*</span>
            </label>
            <input
              type="text"
              id={`recipient-name-${uniqueId}`}
              name="recipient_name"
              class="form-input"
              autocomplete="name"
            />
            <span class="form-error hidden" role="status" aria-live="polite">{t.giftRecipientNameRequired}</span>
          </div>
          <!-- Recipient Email -->
          <div class="form-group">
            <label for={`recipient-email-${uniqueId}`} class="form-label">
              {t.giftRecipientEmail} <span class="required">*</span>
            </label>
            <input
              type="email"
              id={`recipient-email-${uniqueId}`}
              name="recipient_email"
              class="form-input"
              autocomplete="email"
            />
            <span class="form-error hidden" role="status" aria-live="polite">{t.giftRecipientEmailRequired}</span>
          </div>
          <!-- Gift Message (optional) -->
          <div class="form-group">
            <label for={`gift-message-${uniqueId}`} class="form-label">
              {t.giftMessage}
            </label>
            <textarea
              id={`gift-message-${uniqueId}`}
              name="gift_message"
              class="form-textarea"
              rows="3"
              placeholder={t.giftMessagePlaceholder}
            ></textarea>
          </div>
          <!-- Delivery Date (optional) -->
          <div class="form-group">
            <label class="form-label">{t.giftDeliveryDate}</label>
            <div class="gift-delivery-options">
              <label class="radio-label">
                <input type="radio" name="delivery_option" value="immediate" checked class="radio-input" />
                <span class="radio-text">{t.giftDeliveryNow}</span>
              </label>
              <label class="radio-label">
                <input type="radio" name="delivery_option" value="scheduled" class="radio-input" />
                <span class="radio-text">{t.giftDeliveryScheduled}</span>
              </label>
              <label class="radio-label">
                <input type="radio" name="delivery_option" value="no_send" class="radio-input" />
                <span class="radio-text">{t.giftDeliveryNoSend}</span>
              </label>
            </div>
            <!-- Scheduled delivery: date + time -->
            <div class="gift-delivery-scheduled-picker hidden">
              <div class="delivery-datetime-row">
                <input
                  type="date"
                  id={`delivery-date-${uniqueId}`}
                  name="delivery_date"
                  class="form-input delivery-date-input"
                  min={new Date().toISOString().split('T')[0]}
                />
                <input
                  type="time"
                  id={`delivery-time-${uniqueId}`}
                  name="delivery_time"
                  class="form-input delivery-time-input"
                  value="09:00"
                />
              </div>
            </div>
            <!-- No send message -->
            <div class="gift-no-send-message hidden">
              <p class="info-message">{t.giftNoSendMessage}</p>
            </div>
          </div>
        </div>
      </div>

      <!-- WDA-909: Attendees Section - Dynamic list of attendees -->
      <div class="attendees-section">
        <div class="attendees-header">
          <span class="form-label">{t.attendeeData} <span class="required">*</span></span>
          <span class="attendees-count">1/<span class="max-attendees">6</span></span>
        </div>

        <!-- Attendees list container - JS will populate this -->
        <div class="attendees-list">
          <!-- First attendee (main contact) - always visible -->
          <div class="attendee-row main-contact" data-attendee-index="0">
            <div class="attendee-badge">{t.mainContact}</div>
            <div class="attendee-fields">
              <div class="attendee-field">
                <input
                  type="text"
                  name="attendee_name_0"
                  placeholder={t.attendeeName}
                  required
                  class="form-input attendee-name"
                  autocomplete="name"
                />
              </div>
              <div class="attendee-field">
                <input
                  type="email"
                  name="attendee_email_0"
                  placeholder={t.attendeeEmail}
                  class="form-input attendee-email"
                  autocomplete="email"
                />
              </div>
            </div>
          </div>
          <!-- Additional attendees will be added here by JS -->
        </div>

        <!-- Add attendee button -->
        <button type="button" class="add-attendee-btn" data-action="add-attendee" aria-label={t.addAttendee}>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="8" x2="12" y2="16"></line>
            <line x1="8" y1="12" x2="16" y2="12"></line>
          </svg>
          <span class="add-attendee-text">{t.addAttendee}</span>
        </button>

        <!-- WDA-920: Tooltip cuando botón disabled -->
        <span class="add-attendee-disabled-hint hidden" role="tooltip">
          <!-- Mensaje dinámico: "Capacidad máxima alcanzada (X/X plazas)" -->
        </span>

        <span class="form-error attendees-error hidden" role="status" aria-live="polite">{t.attendeesRequired}</span>
      </div>

      <!-- Hidden field to store total attendees count for form submission -->
      <input type="hidden" name="attendees" value="1" />

      <!-- Notes -->
      <div class="form-group">
        <label for={`notes-${uniqueId}`} class="form-label">
          {t.notes}
        </label>
        <textarea
          id={`notes-${uniqueId}`}
          name="notes"
          class="form-textarea"
          rows="3"
        ></textarea>
      </div>

      <!-- Privacy Consent -->
      <div class="form-group privacy-group">
        <label class="privacy-label">
          <input
            type="checkbox"
            name="privacy"
            required
            class="privacy-checkbox"
          />
          <span class="privacy-text">
            {t.gdprLabel}{' '}
            <a href={t.privacyUrl} class="privacy-link" target="_blank" rel="noopener noreferrer">
              {t.privacyLink}
            </a>
            <span class="required">*</span>
          </span>
        </label>
        <span class="form-error hidden">{t.privacyRequired}</span>
      </div>

      <!-- Terms Consent (Safety & Booking Conditions) -->
      <div class="form-group privacy-group">
        <label class="privacy-label">
          <input
            type="checkbox"
            name="terms"
            required
            class="privacy-checkbox"
          />
          <span class="privacy-text">
            {t.termsLabel}{' '}
            <a href={t.termsUrl} class="privacy-link" target="_blank" rel="noopener noreferrer">
              {t.termsLink}
            </a>
            <span class="required">*</span>
          </span>
        </label>
        <span class="form-error hidden">{t.termsRequired}</span>
      </div>

      <!-- WDA-1023: Discount Code Section -->
      <div class="discount-code-wrapper" data-discount-wrapper>
        <DiscountCodeInput sessionPrice={0} locale={locale} />
      </div>

      <!-- WDA-1023: Price Summary -->
      <div class="price-summary" data-price-summary>
        <div class="price-row">
          <span class="price-label">{t.originalPrice}</span>
          <span class="price-value" data-original-price>-</span>
        </div>
        <div class="price-row discount-row hidden" data-discount-row>
          <span class="price-label discount-label">{t.discountApplied}</span>
          <span class="price-value discount-value" data-discount-amount>-</span>
        </div>
        <div class="price-row total-row">
          <span class="price-label">{t.totalPrice}</span>
          <span class="price-value total-value" data-final-price>-</span>
        </div>
      </div>

      <!-- Submit Button -->
      <button type="submit" class="submit-button" disabled>
        <span class="button-text">{t.confirm}</span>
        <span class="button-loading hidden">
          <div class="loading-spinner small"></div>
          <span>{t.submitting}</span>
        </span>
      </button>

      <!-- Form Error -->
      <div class="form-message error-message hidden" role="alert">
        <span class="error-text"></span>
      </div>
    </form>
  </div>

  <!-- Step 4: Confirmation -->
  <div class="booking-step hidden" data-step="confirmation">
    <div class="confirmation-content">
      <!-- Success State -->
      <div class="confirmation-success">
        <div class="success-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
            <polyline points="22 4 12 14.01 9 11.01"></polyline>
          </svg>
        </div>
        <h3 class="success-title">{t.successTitle}</h3>
        <p class="success-message">{t.successMessage}</p>

        <!-- Booking Details (shown for regular bookings) -->
        <div class="booking-details booking-details--regular">
          <div class="detail-row">
            <span class="detail-label">{t.bookingNumber}:</span>
            <span class="detail-value booking-number"></span>
          </div>
          <div class="detail-row">
            <span class="detail-label">{t.bookingDate}:</span>
            <span class="detail-value confirmed-date"></span>
          </div>
          <div class="detail-row">
            <span class="detail-label">{t.bookingTime}:</span>
            <span class="detail-value confirmed-time"></span>
          </div>
          <div class="detail-row">
            <span class="detail-label">{t.bookingAttendees}:</span>
            <span class="detail-value confirmed-attendees"></span>
          </div>
        </div>

        <!-- WDA-1003: Voucher Codes (shown for voucher purchases) -->
        <div class="voucher-codes-section hidden">
          <h4 class="voucher-codes-title">{t.voucherCodesTitle}</h4>
          <div class="voucher-codes-list"></div>
          <p class="voucher-codes-note">{t.voucherCodesNote}</p>
        </div>

        <!-- WDA-1033: Gift Code (shown for gift purchases) -->
        <div class="gift-code-section hidden">
          <h4 class="gift-code-title">{t.giftCodeTitle}</h4>
          <div class="gift-code-display">
            <code class="gift-code"></code>
          </div>
          <p class="gift-code-note">{t.giftCodeNote}</p>
        </div>

        <button type="button" class="new-booking-button" data-action="new-booking">
          {t.newBooking}
        </button>
      </div>

      <!-- Error State -->
      <div class="confirmation-error hidden">
        <div class="error-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="15" y1="9" x2="9" y2="15"></line>
            <line x1="9" y1="9" x2="15" y2="15"></line>
          </svg>
        </div>
        <h3 class="error-title">{t.errorTitle}</h3>
        <p class="error-message-text">{t.errorGeneric}</p>
        <button type="button" class="try-again-button" data-action="try-again">
          {t.tryAgain}
        </button>
      </div>
    </div>
  </div>
</div>

<style>
  /* ============================================
     BASE STYLES
     ============================================ */

  .booking-widget {
    --booking-primary: #DB4529;
    --booking-primary-hover: #BA2515;
    --booking-success: #10b981;
    --booking-error: #ef4444;
    --booking-warning: #f59e0b;
    --booking-gray-50: #f9fafb;
    --booking-gray-100: #f3f4f6;
    --booking-gray-200: #e5e7eb;
    --booking-gray-300: #d1d5db;
    --booking-gray-400: #9ca3af;
    --booking-gray-500: #6b7280;
    --booking-gray-600: #4b5563;
    --booking-gray-700: #374151;
    --booking-gray-800: #1f2937;
    --booking-gray-900: #111827;

    font-family: 'Avenir Next', 'Nunito Sans', sans-serif;
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.1);
    padding: 2rem;
    max-width: 600px;
    margin: 0 auto;
  }

  /* WDA-922: A11Y - Screen reader only */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }

  /* ============================================
     PROGRESS STEPS
     ============================================ */

  .booking-progress {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 2rem;
    padding-bottom: 1.5rem;
    border-bottom: 1px solid var(--booking-gray-200);
  }

  .progress-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    opacity: 0.4;
    transition: opacity 0.3s ease;
    background: none;
    border: none;
    padding: 0;
    cursor: default;
  }

  /* WDA-909: Steps clickables cuando están completed */
  .progress-step.completed {
    opacity: 1;
    cursor: pointer;
  }

  .progress-step.completed:hover .step-number {
    transform: scale(1.1);
  }

  .progress-step.active {
    opacity: 1;
  }

  .progress-step:disabled {
    cursor: not-allowed;
  }

  .step-number {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: var(--booking-gray-200);
    color: var(--booking-gray-600);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.875rem;
    font-weight: 600;
    transition: all 0.3s ease;
  }

  .progress-step.active .step-number {
    background: var(--booking-primary);
    color: white;
  }

  .progress-step.completed .step-number {
    background: var(--booking-success);
    color: white;
  }

  .step-label {
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--booking-gray-600);
    text-align: center;
    max-width: 80px;
    min-height: 32px; /* Force consistent height for 2 lines (16px * 2) */
    line-height: 1.3;
  }

  .progress-connector {
    width: 40px;
    height: 2px;
    background: var(--booking-gray-200);
    margin: 0 0.5rem;
    align-self: flex-start;
    margin-top: 15px; /* Center with step-number (32px / 2 - 1px) */
  }

  /* ============================================
     WDA-974: SESSION TYPE INFO BANNER
     ============================================ */

  .session-type-info {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
    padding: 1rem;
    margin-bottom: 1.5rem;
    background: var(--booking-gray-50);
    border: 1px solid var(--booking-gray-200);
    border-radius: 8px;
  }

  .session-type-info.hidden {
    display: none;
  }

  /* WDA-1003: Generic hidden class for voucher flow elements */
  .progress-step.hidden,
  .progress-connector.hidden,
  .back-button.hidden,
  .selection-summary.hidden,
  .attendees-section.hidden {
    display: none !important;
  }

  .session-type-info[data-session-type="pack"] {
    background: #eff6ff;
    border-color: #3b82f6;
  }

  .session-type-info[data-session-type="voucher"] {
    background: #fef3c7;
    border-color: #f59e0b;
  }

  .session-type-info[data-session-type="private"] {
    background: #f3e8ff;
    border-color: #a855f7;
  }

  .session-type-info .info-icon {
    width: 20px;
    height: 20px;
    flex-shrink: 0;
    margin-top: 2px;
  }

  .session-type-info[data-session-type="pack"] .info-icon {
    color: #3b82f6;
  }

  .session-type-info[data-session-type="voucher"] .info-icon {
    color: #f59e0b;
  }

  .session-type-info[data-session-type="private"] .info-icon {
    color: #a855f7;
  }

  .session-type-text {
    font-size: 0.875rem;
    line-height: 1.5;
    color: var(--booking-gray-700);
    font-weight: 500;
  }

  /* ============================================
     BOOKING STEPS
     ============================================ */

  .booking-step {
    animation: fadeIn 0.3s ease;
  }

  .booking-step.hidden {
    display: none;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .step-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1.5rem;
  }

  .step-title {
    font-family: 'Helvetica Neue', 'Inter', sans-serif;
    font-size: 1.25rem;
    font-weight: 500;
    color: var(--booking-gray-900);
    margin: 0;
  }

  .back-button {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--booking-gray-600);
    background: transparent;
    border: 1px solid var(--booking-gray-300);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .back-button:hover {
    color: var(--booking-gray-900);
    border-color: var(--booking-gray-400);
  }

  .back-button svg {
    width: 16px;
    height: 16px;
  }

  /* ============================================
     CALENDAR
     ============================================ */

  .calendar-container {
    position: relative;
  }

  .calendar-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1rem;
  }

  .calendar-nav {
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--booking-gray-100);
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .calendar-nav:hover {
    background: var(--booking-gray-200);
  }

  .calendar-nav:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  .calendar-nav svg {
    width: 20px;
    height: 20px;
    color: var(--booking-gray-700);
  }

  .calendar-month-year {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--booking-gray-900);
  }

  .calendar-weekdays {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 4px;
    margin-bottom: 0.5rem;
  }

  .weekday {
    text-align: center;
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--booking-gray-500);
    padding: 0.5rem 0;
  }

  .calendar-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 4px;
  }

  /* WDA-909: Usar :global para elementos dinámicos del calendario */
  :global(.calendar-day) {
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.875rem;
    font-weight: 500;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    background: transparent;
    color: var(--booking-gray-700);
    min-height: 40px;
    position: relative;
  }

  :global(.calendar-day.empty) {
    cursor: default;
  }

  :global(.calendar-day.disabled) {
    color: var(--booking-gray-300);
    cursor: not-allowed;
  }

  /* WDA-909: Sistema de estados visuales para días (usando :global para elementos dinámicos) */
  :global(.calendar-day.available) {
    background: rgba(16, 185, 129, 0.1) !important; /* Verde suave */
    color: var(--booking-gray-900) !important;
    position: relative;
  }

  :global(.calendar-day.available)::after {
    content: '';
    position: absolute;
    bottom: 4px;
    left: 50%;
    transform: translateX(-50%);
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background: var(--booking-success);
  }

  :global(.calendar-day.available:hover) {
    background: var(--booking-primary) !important;
    color: white !important;
  }

  :global(.calendar-day.available:hover)::after {
    background: white;
  }

  /* Estado: disponible pero pocas plazas */
  :global(.calendar-day.low-availability) {
    background: rgba(245, 158, 11, 0.1) !important; /* Naranja suave */
    color: var(--booking-gray-900) !important;
    position: relative;
  }

  :global(.calendar-day.low-availability)::after {
    content: '';
    position: absolute;
    bottom: 4px;
    left: 50%;
    transform: translateX(-50%);
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background: #f59e0b;
  }

  :global(.calendar-day.low-availability:hover) {
    background: var(--booking-primary) !important;
    color: white !important;
  }

  :global(.calendar-day.low-availability:hover)::after {
    background: white;
  }

  /* Estado: completo (sin disponibilidad) */
  :global(.calendar-day.full) {
    background: rgba(239, 68, 68, 0.05) !important;
    color: var(--booking-gray-400) !important;
    cursor: not-allowed;
    position: relative;
  }

  :global(.calendar-day.full)::after {
    content: '';
    position: absolute;
    bottom: 4px;
    left: 50%;
    transform: translateX(-50%);
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background: var(--booking-error);
  }

  :global(.calendar-day.selected) {
    background: var(--booking-primary) !important;
    color: white !important;
  }

  :global(.calendar-day.selected)::after {
    background: white;
  }

  .calendar-day.today {
    box-shadow: inset 0 0 0 2px var(--booking-primary);
  }

  /* ============================================
     TIME SLOTS
     ============================================ */

  .selected-date-display {
    padding: 1rem;
    background: var(--booking-gray-50);
    border-radius: 8px;
    margin-bottom: 1.5rem;
    font-size: 1rem;
    font-weight: 500;
    color: var(--booking-gray-900);
    text-align: center;
  }

  .slots-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 1rem;
  }

  .time-slot {
    padding: 1rem;
    background: white;
    border: 2px solid var(--booking-gray-200);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
  }

  .time-slot:hover:not(.disabled) {
    border-color: var(--booking-primary);
    box-shadow: 0 2px 8px rgba(219, 69, 41, 0.15);
  }

  .time-slot.selected {
    border-color: var(--booking-primary);
    background: rgba(219, 69, 41, 0.05);
  }

  .time-slot.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    background: var(--booking-gray-50);
  }

  .slot-time {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--booking-gray-900);
    margin-bottom: 0.25rem;
  }

  .slot-capacity {
    font-size: 0.75rem;
    color: var(--booking-gray-500);
  }

  .slot-capacity.low {
    color: #f59e0b;
  }

  .slot-capacity.full {
    color: var(--booking-error);
  }

  /* WDA-1004: Private session slots */
  .slot-capacity.private {
    color: #8b5cf6; /* Purple for exclusive */
    font-weight: 600;
  }

  .time-slot.private-slot {
    border-color: #8b5cf6;
  }

  .time-slot.private-slot:hover:not(.disabled) {
    border-color: #7c3aed;
    background: rgba(139, 92, 246, 0.05);
  }

  .time-slot.private-slot.selected {
    border-color: #7c3aed;
    background: rgba(139, 92, 246, 0.1);
  }

  /* ============================================
     FORM
     ============================================ */

  .selection-summary {
    display: flex;
    gap: 2rem;
    padding: 1rem;
    background: var(--booking-gray-50);
    border-radius: 8px;
    margin-bottom: 1.5rem;
  }

  .summary-item {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .summary-label {
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--booking-gray-500);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .summary-value {
    font-size: 1rem;
    font-weight: 600;
    color: var(--booking-gray-900);
  }

  .booking-form {
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
  }

  .form-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .form-label {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--booking-gray-700);
  }

  .required {
    color: var(--booking-error);
  }

  .form-input,
  .form-select,
  .form-textarea {
    width: 100%;
    padding: 0.75rem 1rem;
    font-family: inherit;
    font-size: 1rem;
    color: var(--booking-gray-900);
    background: white;
    border: 1px solid var(--booking-gray-300);
    border-radius: 8px;
    transition: all 0.2s ease;
  }

  .form-input:focus,
  .form-select:focus,
  .form-textarea:focus {
    outline: none;
    border-color: var(--booking-primary);
    box-shadow: 0 0 0 3px rgba(219, 69, 41, 0.15);
  }

  .form-input.error,
  .form-select.error,
  .form-textarea.error {
    border-color: var(--booking-error);
  }

  .form-error {
    font-size: 0.75rem;
    color: var(--booking-error);
  }

  .form-error.hidden {
    display: none;
  }

  .form-textarea {
    resize: vertical;
    min-height: 80px;
  }

  /* WDA-909: Attendees Section */
  .attendees-section {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .attendees-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .attendees-count {
    font-size: 0.875rem;
    color: var(--booking-gray-500);
    font-weight: 500;
  }

  .attendees-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  /* Estilos base para attendee-row (el primer asistente está en el HTML) */
  .attendee-row {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    background: var(--booking-gray-50);
    border-radius: 8px;
    position: relative;
  }

  .attendee-row.main-contact {
    background: rgba(219, 69, 41, 0.05);
    border: 1px solid rgba(219, 69, 41, 0.2);
  }

  .attendee-badge {
    font-size: 0.625rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--booking-primary);
    margin-bottom: 0.25rem;
  }

  .attendee-fields {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.75rem;
  }

  .attendee-field {
    display: flex;
    flex-direction: column;
  }

  .attendee-row .form-input {
    padding: 0.75rem 1rem;
    font-size: 0.9375rem;
    background: white;
    border: 1px solid var(--booking-gray-300);
  }

  .attendee-row .form-input::placeholder {
    color: var(--booking-gray-400);
  }

  /* ============================================
     ESTILOS PARA ASISTENTES DINAMICOS (JS)
     Usar :global() porque son generados por JS
     ============================================ */

  /* Asistentes adicionales generados por JS */
  :global(.attendees-list .attendee-row:not(.main-contact)) {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    padding-top: 2.5rem;
    background: var(--booking-gray-50);
    border-radius: 8px;
    position: relative;
    border: 1px solid var(--booking-gray-200);
  }

  :global(.attendees-list .attendee-row:not(.main-contact) .attendee-fields) {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.75rem;
  }

  :global(.attendees-list .attendee-row:not(.main-contact) .form-input) {
    width: 100%;
    padding: 0.75rem 1rem;
    font-family: inherit;
    font-size: 0.9375rem;
    color: var(--booking-gray-900);
    background: white;
    border: 1px solid var(--booking-gray-300);
    border-radius: 8px;
    transition: all 0.2s ease;
  }

  :global(.attendees-list .attendee-row:not(.main-contact) .form-input:focus) {
    outline: none;
    border-color: var(--booking-primary);
    box-shadow: 0 0 0 3px rgba(219, 69, 41, 0.15);
  }

  :global(.attendees-list .attendee-row:not(.main-contact) .form-input::placeholder) {
    color: var(--booking-gray-400);
  }

  /* Botón eliminar en esquina superior derecha */
  :global(.attendees-list .attendee-actions) {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
  }

  :global(.attendees-list .remove-attendee-btn) {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    font-family: inherit;
    font-size: 0.6875rem;
    font-weight: 500;
    color: var(--booking-error);
    background: white;
    border: 1px solid var(--booking-gray-200);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  :global(.attendees-list .remove-attendee-btn:hover) {
    background: rgba(239, 68, 68, 0.1);
    border-color: var(--booking-error);
  }

  :global(.attendees-list .remove-attendee-btn svg) {
    width: 12px;
    height: 12px;
  }

  .add-attendee-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    font-family: inherit;
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--booking-primary);
    background: transparent;
    border: 2px dashed var(--booking-gray-300);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .add-attendee-btn:hover {
    border-color: var(--booking-primary);
    background: rgba(219, 69, 41, 0.05);
  }

  .add-attendee-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    border-color: var(--booking-gray-200);
  }

  .add-attendee-btn svg {
    width: 18px;
    height: 18px;
  }

  .attendees-error {
    margin-top: 0.5rem;
  }

  /* Privacy */
  .privacy-group {
    margin-top: 0.5rem;
  }

  .privacy-label {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
    cursor: pointer;
  }

  .privacy-checkbox {
    width: 18px;
    height: 18px;
    margin-top: 2px;
    accent-color: var(--booking-primary);
    cursor: pointer;
  }

  .privacy-text {
    font-size: 0.875rem;
    color: var(--booking-gray-600);
    line-height: 1.5;
  }

  .privacy-link {
    color: var(--booking-primary);
    text-decoration: underline;
  }

  .privacy-link:hover {
    color: var(--booking-primary-hover);
  }

  /* Submit Button */
  .submit-button {
    width: 100%;
    padding: 1rem 2rem;
    margin-top: 0.5rem;
    font-family: inherit;
    font-size: 1rem;
    font-weight: 600;
    color: white;
    background: var(--booking-primary);
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
  }

  .submit-button:hover:not(:disabled) {
    background: var(--booking-primary-hover);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(219, 69, 41, 0.3);
  }

  .submit-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .button-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
  }

  .button-loading.hidden {
    display: none;
  }

  .submit-button.submitting .button-text {
    display: none;
  }

  .submit-button.submitting .button-loading {
    display: flex;
  }

  .form-message {
    padding: 1rem;
    border-radius: 8px;
    font-size: 0.875rem;
    text-align: center;
  }

  .error-message {
    background: #fee2e2;
    color: #991b1b;
  }

  .error-message.hidden {
    display: none;
  }

  /* ============================================
     WDA-920: CAPACITY WARNING & BADGE
     ============================================ */

  .capacity-warning {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 1rem;
    margin-bottom: 1rem;
    background: rgba(245, 158, 11, 0.1);
    border: 1px solid var(--booking-warning);
    border-radius: 8px;
    color: #92400e;
    font-size: 0.875rem;
    font-weight: 500;
  }

  .capacity-warning svg {
    width: 20px;
    height: 20px;
    color: var(--booking-warning);
    flex-shrink: 0;
  }

  .capacity-warning.hidden {
    display: none;
  }

  .slot-capacity-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    margin-bottom: 1rem;
    background: var(--booking-gray-50);
    border-radius: 6px;
    font-size: 0.875rem;
    font-weight: 500;
  }

  .slot-capacity-badge.green {
    background: rgba(16, 185, 129, 0.1);
    color: #065f46;
  }

  .slot-capacity-badge.yellow {
    background: rgba(245, 158, 11, 0.1);
    color: #92400e;
  }

  .slot-capacity-badge.red {
    background: rgba(239, 68, 68, 0.1);
    color: #991b1b;
  }

  .slot-capacity-badge.hidden {
    display: none;
  }

  .add-attendee-btn {
    position: relative;
  }

  .add-attendee-disabled-hint {
    display: none;
    position: absolute;
    bottom: calc(100% + 0.5rem);
    left: 50%;
    transform: translateX(-50%);
    padding: 0.5rem 0.75rem;
    background: var(--booking-gray-800);
    color: white;
    font-size: 0.75rem;
    border-radius: 6px;
    white-space: nowrap;
    pointer-events: none;
    z-index: 10;
  }

  .add-attendee-disabled-hint::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 5px solid transparent;
    border-top-color: var(--booking-gray-800);
  }

  .add-attendee-btn:disabled:hover + .add-attendee-disabled-hint {
    display: block;
  }

  /* ============================================
     WDA-921: RATE LIMITING
     ============================================ */

  .rate-limit-message {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    padding: 1rem;
    margin-bottom: 1rem;
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid var(--booking-error);
    border-radius: 8px;
    color: #991b1b;
    font-size: 0.875rem;
    font-weight: 500;
    text-align: center;
  }

  .rate-limit-message.hidden {
    display: none;
  }

  /* ============================================
     CONFIRMATION
     ============================================ */

  .confirmation-content {
    text-align: center;
    padding: 2rem 0;
  }

  .success-icon,
  .error-icon {
    width: 64px;
    height: 64px;
    margin: 0 auto 1.5rem;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .success-icon {
    background: rgba(16, 185, 129, 0.1);
  }

  .success-icon svg {
    width: 32px;
    height: 32px;
    color: var(--booking-success);
  }

  .error-icon {
    background: rgba(239, 68, 68, 0.1);
  }

  .error-icon svg {
    width: 32px;
    height: 32px;
    color: var(--booking-error);
  }

  .success-title,
  .error-title {
    font-family: 'Helvetica Neue', 'Inter', sans-serif;
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--booking-gray-900);
    margin: 0 0 0.5rem;
  }

  .success-message,
  .error-message-text {
    font-size: 1rem;
    color: var(--booking-gray-600);
    margin: 0 0 2rem;
  }

  .booking-details {
    background: var(--booking-gray-50);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 2rem;
    text-align: left;
  }

  .detail-row {
    display: flex;
    justify-content: space-between;
    padding: 0.75rem 0;
    border-bottom: 1px solid var(--booking-gray-200);
  }

  .detail-row:last-child {
    border-bottom: none;
  }

  .detail-label {
    font-size: 0.875rem;
    color: var(--booking-gray-500);
  }

  .detail-value {
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--booking-gray-900);
  }

  .new-booking-button,
  .try-again-button {
    padding: 0.875rem 2rem;
    font-family: inherit;
    font-size: 1rem;
    font-weight: 500;
    color: var(--booking-primary);
    background: transparent;
    border: 2px solid var(--booking-primary);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .new-booking-button:hover,
  .try-again-button:hover {
    background: var(--booking-primary);
    color: white;
  }

  .confirmation-error.hidden {
    display: none;
  }

  /* WDA-1003: Voucher Codes Section */
  .voucher-codes-section {
    background: linear-gradient(135deg, var(--booking-gray-50), #fff);
    border: 2px solid var(--booking-success);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 2rem;
    text-align: center;
  }

  .voucher-codes-section.hidden {
    display: none;
  }

  .voucher-codes-title {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--booking-gray-900);
    margin: 0 0 1rem;
  }

  .voucher-codes-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .voucher-code-item {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    background: white;
    border: 1px solid var(--booking-gray-200);
    border-radius: 8px;
    padding: 0.875rem 1rem;
  }

  .voucher-code {
    font-family: 'Courier New', monospace;
    font-size: 1.125rem;
    font-weight: 700;
    color: var(--booking-primary);
    letter-spacing: 0.05em;
  }

  .copy-code-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    padding: 0;
    background: var(--booking-gray-100);
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    color: var(--booking-gray-600);
  }

  .copy-code-btn:hover {
    background: var(--booking-gray-200);
    color: var(--booking-gray-900);
  }

  .copy-code-btn.copied {
    background: var(--booking-success);
    color: white;
  }

  .voucher-codes-note {
    font-size: 0.875rem;
    color: var(--booking-gray-500);
    margin: 1rem 0 0;
  }

  /* WDA-1033: Gift Recipient Section */
  .gift-recipient-section {
    background: linear-gradient(135deg, #fce7f3, #fdf2f8);
    border: 2px solid #ec4899;
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
  }

  .gift-recipient-section.hidden {
    display: none;
  }

  .gift-section-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 1rem;
  }

  .gift-icon {
    width: 24px;
    height: 24px;
    color: #ec4899;
  }

  .gift-recipient-fields {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .gift-delivery-options {
    display: flex;
    gap: 1.5rem;
    margin-bottom: 0.5rem;
  }

  .radio-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
  }

  .radio-input {
    width: 18px;
    height: 18px;
    accent-color: #ec4899;
  }

  .radio-text {
    font-size: 0.875rem;
    color: var(--booking-gray-700);
  }

  .gift-delivery-scheduled-picker {
    margin-top: 0.75rem;
  }

  .gift-delivery-scheduled-picker.hidden {
    display: none;
  }

  .delivery-datetime-row {
    display: flex;
    gap: 0.75rem;
  }

  .delivery-datetime-row .delivery-date-input {
    flex: 1;
  }

  .delivery-datetime-row .delivery-time-input {
    width: 120px;
  }

  .gift-no-send-message {
    margin-top: 0.75rem;
  }

  .gift-no-send-message.hidden {
    display: none;
  }

  .gift-no-send-message .info-message {
    background: #fef3c7;
    border: 1px solid #f59e0b;
    border-radius: 8px;
    padding: 0.75rem 1rem;
    font-size: 0.875rem;
    color: #92400e;
    margin: 0;
  }

  /* WDA-1033: Gift Code Section (confirmation) */
  .gift-code-section {
    background: linear-gradient(135deg, #fce7f3, #fdf2f8);
    border: 2px solid #ec4899;
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 2rem;
    text-align: center;
  }

  .gift-code-section.hidden {
    display: none;
  }

  .gift-code-title {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--booking-gray-900);
    margin: 0 0 1rem;
  }

  .gift-code-display {
    background: white;
    border: 1px solid var(--booking-gray-200);
    border-radius: 8px;
    padding: 1rem;
  }

  .gift-code {
    font-family: 'Courier New', monospace;
    font-size: 1.25rem;
    font-weight: 700;
    color: #ec4899;
    letter-spacing: 0.05em;
  }

  .gift-code-note {
    font-size: 0.875rem;
    color: var(--booking-gray-500);
    margin: 1rem 0 0;
  }

  /* WDA-1033: Session type info for gift */
  .session-type-info[data-session-type="gift"] {
    background: #fdf2f8;
    border-color: #ec4899;
  }

  .session-type-info[data-session-type="gift"] .info-icon {
    color: #ec4899;
  }

  /* ============================================
     LOADING STATES
     ============================================ */

  .calendar-loading,
  .slots-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 3rem;
    gap: 1rem;
    color: var(--booking-gray-500);
  }

  .calendar-loading.hidden,
  .slots-loading.hidden {
    display: none;
  }

  .loading-spinner {
    width: 32px;
    height: 32px;
    border: 3px solid var(--booking-gray-200);
    border-top-color: var(--booking-primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  .loading-spinner.small {
    width: 20px;
    height: 20px;
    border-width: 2px;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  .calendar-empty,
  .slots-empty {
    text-align: center;
    padding: 2rem;
    color: var(--booking-gray-500);
  }

  .calendar-empty.hidden,
  .slots-empty.hidden {
    display: none;
  }

  /* ============================================
     RESPONSIVE
     ============================================ */

  @media (max-width: 640px) {
    .booking-widget {
      padding: 1.5rem;
      border-radius: 0;
      box-shadow: none;
    }

    .booking-progress {
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .progress-connector {
      display: none;
    }

    .step-label {
      font-size: 0.625rem;
    }

    .step-header {
      flex-direction: column;
      gap: 1rem;
      align-items: flex-start;
    }

    .selection-summary {
      flex-direction: column;
      gap: 1rem;
    }

    .slots-container {
      grid-template-columns: repeat(2, 1fr);
    }

    /* WDA-909: Attendees mobile */
    .attendee-fields {
      grid-template-columns: 1fr;
    }

    .attendee-row {
      padding: 0.875rem;
    }

    /* Asistentes dinámicos en mobile */
    :global(.attendees-list .attendee-row:not(.main-contact)) {
      padding: 0.875rem;
      padding-top: 2.25rem;
    }

    :global(.attendees-list .attendee-row:not(.main-contact) .attendee-fields) {
      grid-template-columns: 1fr;
    }

    :global(.attendees-list .attendee-actions) {
      top: 0.375rem;
      right: 0.375rem;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .booking-step,
    .calendar-day,
    .time-slot,
    .submit-button,
    .loading-spinner {
      animation: none;
      transition: none;
    }
  }

  /* ===========================================
     WDA-1023: DISCOUNT CODE STYLES
     =========================================== */

  .discount-code-wrapper {
    margin: 1.5rem 0;
    padding: 1rem;
    background: var(--bg-accent, #f8f9fa);
    border-radius: 0.5rem;
    border: 1px solid var(--border-color, #e5e7eb);
  }

  .price-summary {
    margin: 1.5rem 0;
    padding: 1rem;
    background: var(--bg-primary, #fff);
    border-radius: 0.5rem;
    border: 1px solid var(--border-color, #e5e7eb);
  }

  .price-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0;
  }

  .price-row.hidden {
    display: none;
  }

  .price-row:not(:last-child) {
    border-bottom: 1px dashed var(--border-color, #e5e7eb);
  }

  .price-label {
    font-size: 0.875rem;
    color: var(--text-secondary, #6b7280);
  }

  .price-value {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--text-primary, #1f2937);
  }

  .discount-row .discount-label {
    color: var(--color-success, #16a34a);
  }

  .discount-row .discount-value {
    color: var(--color-success, #16a34a);
    font-weight: 600;
  }

  .total-row .price-label {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary, #1f2937);
  }

  .total-row .total-value {
    font-size: 1.125rem;
    font-weight: 700;
    color: var(--color-primary, #d4a574);
  }

  @media (max-width: 640px) {
    .discount-code-wrapper,
    .price-summary {
      padding: 0.75rem;
      margin: 1rem 0;
    }

    .price-label,
    .price-value {
      font-size: 0.8125rem;
    }

    .total-row .price-label {
      font-size: 0.9375rem;
    }

    .total-row .total-value {
      font-size: 1rem;
    }
  }
</style>

<script>
  /**
   * BookingWidgetController
   * Handles all client-side logic for the booking widget
   */
  import {
    getAvailableDates,
    getDaySlots,
    createBooking,
    formatTime,
    formatDate,
    getDefaultDateRange,
    getCapacityColor,
  } from '../../lib/booking';
  import type {
    DateAvailability,
    TimeSlot,
    DayAvailability,
    CreateBookingRequest,
    DeliveryOption,
  } from '../../lib/booking';
  // WDA-1023: Discount store imports
  import {
    appliedDiscount,
    clearDiscount,
  } from '../../stores';
  import type { Discount } from '../../types/discount';

  interface WidgetState {
    sessionId: number;
    locale: string;
    translations: Record<string, any>;
    currentMonth: Date;
    availableDates: Map<string, DateAvailability>;
    selectedDate: string | null;
    daySlots: TimeSlot[];
    selectedSlot: TimeSlot | null;
    maxCapacity: number;
    // WDA-909: Multi-attendee support
    attendeeCount: number;
    // WDA-921: Rate limiting
    rateLimitUntil: number | null;
    rateLimitCountdown: number;
    // WDA-974: Session type support
    sessionType: 'single' | 'pack' | 'voucher' | 'private' | 'gift';
    includedPersons: number | null;
    // WDA-1008: Voucher validity from backend (also used for gift)
    voucherValidityMonths: number;
    // WDA-1023: Session price for discount calculations
    sessionPrice: number;
  }

  class BookingWidgetController {
    private widget: HTMLElement;
    private state: WidgetState;

    constructor(widget: HTMLElement) {
      this.widget = widget;
      this.state = {
        sessionId: parseInt(widget.dataset.sessionId || '0'),
        locale: widget.dataset.locale || 'es',
        translations: JSON.parse(widget.dataset.translations || '{}'),
        currentMonth: new Date(),
        availableDates: new Map(),
        selectedDate: null,
        daySlots: [],
        selectedSlot: null,
        maxCapacity: 6,
        attendeeCount: 1,
        rateLimitUntil: null,
        rateLimitCountdown: 0,
        // WDA-974: Default to single type (backward compatible)
        sessionType: 'single',
        includedPersons: null,
        // WDA-1008: Default voucher validity (also used for gift)
        voucherValidityMonths: 12,
        // WDA-1023: Session price for discount calculations
        sessionPrice: 0,
      };

      // WDA-1023: Subscribe to discount store changes
      this.subscribeToDiscountStore();

      this.init();
    }

    private async init(): Promise<void> {
      this.bindEvents();
      // WDA-974: Load session type first
      await this.loadSessionType();
      await this.loadAvailableDates();
      this.renderCalendar();
    }

    private bindEvents(): void {
      // Calendar navigation
      const prevBtn = this.widget.querySelector('.prev-month');
      const nextBtn = this.widget.querySelector('.next-month');
      prevBtn?.addEventListener('click', () => this.navigateMonth(-1));
      nextBtn?.addEventListener('click', () => this.navigateMonth(1));

      // WDA-909: Progress steps clickables para volver atrás
      this.widget.querySelectorAll('.progress-step').forEach((step) => {
        step.addEventListener('click', (e) => {
          const stepEl = e.currentTarget as HTMLButtonElement;
          if (stepEl.classList.contains('completed')) {
            const stepName = stepEl.dataset.step as 'calendar' | 'slots' | 'form' | 'confirmation';
            if (stepName && stepName !== 'confirmation') {
              this.showStep(stepName);
            }
          }
        });
      });

      // Back buttons
      this.widget.querySelectorAll('[data-action]').forEach((btn) => {
        btn.addEventListener('click', (e) => {
          const action = (e.currentTarget as HTMLElement).dataset.action;
          this.handleAction(action || '');
        });
      });

      // Form submission
      const form = this.widget.querySelector('.booking-form');
      form?.addEventListener('submit', (e) => this.handleSubmit(e as SubmitEvent));

      // Form validation on input
      form?.addEventListener('input', () => this.updateSubmitButton());
      form?.addEventListener('change', () => this.updateSubmitButton());

      // Auto-fill first attendee from buyer data
      const customerNameInput = form?.querySelector('input[name="customer_name"]') as HTMLInputElement;
      const customerEmailInput = form?.querySelector('input[name="customer_email"]') as HTMLInputElement;
      const attendeeNameInput = form?.querySelector('input[name="attendee_name_0"]') as HTMLInputElement;
      const attendeeEmailInput = form?.querySelector('input[name="attendee_email_0"]') as HTMLInputElement;

      customerNameInput?.addEventListener('input', () => {
        if (attendeeNameInput) {
          attendeeNameInput.value = customerNameInput.value;
        }
      });

      customerEmailInput?.addEventListener('input', () => {
        if (attendeeEmailInput) {
          attendeeEmailInput.value = customerEmailInput.value;
        }
      });

      // WDA-1033: Gift delivery option toggle (immediate, scheduled, no_send)
      const deliveryOptions = this.widget.querySelectorAll('input[name="delivery_option"]');
      const scheduledPicker = this.widget.querySelector('.gift-delivery-scheduled-picker');
      const noSendMessage = this.widget.querySelector('.gift-no-send-message');

      deliveryOptions.forEach((radio) => {
        radio.addEventListener('change', (e) => {
          const value = (e.target as HTMLInputElement).value;

          // Hide all conditional elements first
          scheduledPicker?.classList.add('hidden');
          noSendMessage?.classList.add('hidden');

          // Show relevant element based on selection
          if (value === 'scheduled') {
            scheduledPicker?.classList.remove('hidden');
          } else if (value === 'no_send') {
            noSendMessage?.classList.remove('hidden');
          }
          // 'immediate' shows nothing extra
        });
      });
    }

    private handleAction(action: string): void {
      switch (action) {
        case 'back-to-calendar':
          this.showStep('calendar');
          break;
        case 'back-to-slots':
          this.showStep('slots');
          break;
        case 'new-booking':
        case 'try-again':
          this.resetWidget();
          break;
      }
    }

    // =========================================
    // WDA-974: SESSION TYPE
    // =========================================

    private async loadSessionType(): Promise<void> {
      try {
        const response = await fetch('https://backend.sauwasauna.com/graphql', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            query: `
              query GetSessionType($sessionId: ID!) {
                session(id: $sessionId, idType: DATABASE_ID) {
                  databaseId
                  sessionDetails {
                    sessionType
                    includedPersons
                    voucherValidityMonths
                    sessionPrice
                  }
                }
              }
            `,
            variables: { sessionId: this.state.sessionId },
          }),
        });

        const result = await response.json();
        const sessionDetails = result?.data?.session?.sessionDetails;

        if (sessionDetails) {
          // WDA-974: sessionType comes as array from ACF select field, extract first value
          const rawType = sessionDetails.sessionType;
          this.state.sessionType = Array.isArray(rawType) ? rawType[0] : (rawType || 'single');
          this.state.includedPersons = sessionDetails.includedPersons || null;
          // WDA-1008: Store voucher validity months for display (also used for gift)
          this.state.voucherValidityMonths = sessionDetails.voucherValidityMonths || 12;
          // WDA-1023: Store session price for discount calculations
          this.state.sessionPrice = sessionDetails.sessionPrice || 0;

          // Update UI based on session type
          this.updateSessionTypeUI();
          // WDA-1023: Initialize price summary
          this.updatePriceSummary(null);
        }
      } catch (error) {
        console.error('[BookingWidget] Error loading session type:', error);
        // Fallback to single type (backward compatible)
        this.state.sessionType = 'single';
      }
    }

    private updateSessionTypeUI(): void {
      const { sessionType, includedPersons, translations } = this.state;
      const infoBanner = this.widget.querySelector('.session-type-info');
      const infoBannerText = this.widget.querySelector('.session-type-text');

      // Hide calendar for voucher purchases - vouchers don't need date/time selection
      if (sessionType === 'voucher') {
        // Hide calendar and slots steps
        const calendarStep = this.widget.querySelector('[data-step="calendar"]');
        const slotsStep = this.widget.querySelector('[data-step="slots"]');
        calendarStep?.classList.add('hidden');
        slotsStep?.classList.add('hidden');

        // Hide progress indicators for calendar/slots (steps 1 and 2)
        const calendarProgress = this.widget.querySelector('[data-step-index="0"]');
        const slotsProgress = this.widget.querySelector('[data-step-index="1"]');
        const connector1 = calendarProgress?.nextElementSibling;
        const connector2 = slotsProgress?.nextElementSibling;
        calendarProgress?.classList.add('hidden');
        slotsProgress?.classList.add('hidden');
        connector1?.classList.add('hidden');
        connector2?.classList.add('hidden');

        // Hide "Cambiar horario" button - vouchers don't have time slots
        const changeSlotBtn = this.widget.querySelector('[data-action="back-to-slots"]');
        changeSlotBtn?.classList.add('hidden');

        // Hide selection summary (date/time) - not applicable for vouchers
        const selectionSummary = this.widget.querySelector('.selection-summary');
        selectionSummary?.classList.add('hidden');

        // Hide attendees section - vouchers are purchased, not attended
        const attendeesSection = this.widget.querySelector('.attendees-section');
        attendeesSection?.classList.add('hidden');

        // Renumber visible progress steps (form becomes step 1, confirmation step 2)
        const formProgress = this.widget.querySelector('[data-step-index="2"]');
        const confirmProgress = this.widget.querySelector('[data-step-index="3"]');
        if (formProgress) {
          const stepNumber = formProgress.querySelector('.step-number');
          if (stepNumber) stepNumber.textContent = '1';
        }
        if (confirmProgress) {
          const stepNumber = confirmProgress.querySelector('.step-number');
          if (stepNumber) stepNumber.textContent = '2';
        }

        // Show form directly
        this.showStep('form');
      }

      // WDA-1033: Gift purchases - similar to vouchers but with recipient section
      if (sessionType === 'gift') {
        // Hide calendar and slots steps
        const calendarStep = this.widget.querySelector('[data-step="calendar"]');
        const slotsStep = this.widget.querySelector('[data-step="slots"]');
        calendarStep?.classList.add('hidden');
        slotsStep?.classList.add('hidden');

        // Hide progress indicators for calendar/slots (steps 1 and 2)
        const calendarProgress = this.widget.querySelector('[data-step-index="0"]');
        const slotsProgress = this.widget.querySelector('[data-step-index="1"]');
        const connector1 = calendarProgress?.nextElementSibling;
        const connector2 = slotsProgress?.nextElementSibling;
        calendarProgress?.classList.add('hidden');
        slotsProgress?.classList.add('hidden');
        connector1?.classList.add('hidden');
        connector2?.classList.add('hidden');

        // Hide "Cambiar horario" button - gifts don't have time slots
        const changeSlotBtn = this.widget.querySelector('[data-action="back-to-slots"]');
        changeSlotBtn?.classList.add('hidden');

        // Hide selection summary (date/time) - not applicable for gifts
        const selectionSummary = this.widget.querySelector('.selection-summary');
        selectionSummary?.classList.add('hidden');

        // Hide attendees section - gifts are purchased, recipient redeems later
        const attendeesSection = this.widget.querySelector('.attendees-section');
        attendeesSection?.classList.add('hidden');

        // Show recipient section for gifts
        const recipientSection = this.widget.querySelector('.gift-recipient-section');
        recipientSection?.classList.remove('hidden');

        // Renumber visible progress steps (form becomes step 1, confirmation step 2)
        const formProgress = this.widget.querySelector('[data-step-index="2"]');
        const confirmProgress = this.widget.querySelector('[data-step-index="3"]');
        if (formProgress) {
          const stepNumber = formProgress.querySelector('.step-number');
          if (stepNumber) stepNumber.textContent = '1';
        }
        if (confirmProgress) {
          const stepNumber = confirmProgress.querySelector('.step-number');
          if (stepNumber) stepNumber.textContent = '2';
        }

        // Show form directly
        this.showStep('form');
      }

      // Show info banner for pack, voucher, or private types
      if (sessionType !== 'single' && infoBanner && infoBannerText) {
        infoBanner.setAttribute('data-session-type', sessionType);

        let infoText = '';
        if (sessionType === 'pack' && includedPersons) {
          infoText = translations.packInfo.replace('{n}', includedPersons);
          // Set fixed attendee count for packs
          this.state.attendeeCount = 1; // Start with 1, will add more below
          this.state.maxCapacity = includedPersons;
          // Pre-populate attendee forms for pack
          setTimeout(() => this.initializePackAttendees(includedPersons), 100);
        } else if (sessionType === 'voucher' && includedPersons) {
          // WDA-1008: Use dynamic validity months from backend
          infoText = translations.voucherInfo
            .replace('{n}', String(includedPersons))
            .replace('{m}', String(this.state.voucherValidityMonths));
        } else if (sessionType === 'private') {
          infoText = translations.privateInfo;
          // For private sessions, allow flexible attendee count up to max
          // No pre-population needed
        } else if (sessionType === 'gift' && includedPersons) {
          // WDA-1033: Gift info text
          infoText = translations.giftInfo.replace('{n}', String(includedPersons));
        }

        infoBannerText.textContent = infoText;
        infoBanner.classList.remove('hidden');
      }

      // Disable add attendee button for pack/private types
      if (sessionType === 'pack') {
        // Pack types have fixed attendee count
        const addAttendeeBtn = this.widget.querySelector('.add-attendee-btn');
        addAttendeeBtn?.setAttribute('disabled', 'true');
        addAttendeeBtn?.classList.add('hidden');
      }
    }

    // =========================================
    // CALENDAR
    // =========================================

    private async loadAvailableDates(): Promise<void> {
      const loading = this.widget.querySelector('.calendar-loading');
      const grid = this.widget.querySelector('.calendar-grid');
      const empty = this.widget.querySelector('.calendar-empty');

      loading?.classList.remove('hidden');
      grid?.classList.add('hidden');
      empty?.classList.add('hidden');

      try {
        const { startDate, endDate } = getDefaultDateRange();
        const dates = await getAvailableDates({
          sessionId: this.state.sessionId,
          startDate,
          endDate,
        });

        // WDA-909: Guardar todos los datos de fechas para mostrar estados visuales
        this.state.availableDates.clear();
        let hasAnyAvailable = false;
        dates.forEach((d) => {
          this.state.availableDates.set(d.date, d);
          if (d.hasSlots) hasAnyAvailable = true;
        });

        if (!hasAnyAvailable) {
          empty?.classList.remove('hidden');
        } else {
          grid?.classList.remove('hidden');
        }
      } catch (error) {
        console.error('[BookingWidget] Error loading dates:', error);
        empty?.classList.remove('hidden');
      } finally {
        loading?.classList.add('hidden');
      }
    }

    private renderCalendar(): void {
      const { currentMonth, availableDates, translations, locale } = this.state;

      // Update month/year display
      const monthYearEl = this.widget.querySelector('.calendar-month-year');
      if (monthYearEl) {
        const months = translations.months as unknown as string[];
        monthYearEl.textContent = `${months[currentMonth.getMonth()]} ${currentMonth.getFullYear()}`;
      }

      // Get first day of month and total days
      const firstDay = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), 1);
      const lastDay = new Date(currentMonth.getFullYear(), currentMonth.getMonth() + 1, 0);
      const startOffset = (firstDay.getDay() + 6) % 7; // Monday = 0
      const totalDays = lastDay.getDate();

      // Build calendar grid
      const grid = this.widget.querySelector('.calendar-grid');
      if (!grid) return;

      let html = '';

      // Empty cells for offset
      for (let i = 0; i < startOffset; i++) {
        html += '<button type="button" class="calendar-day empty" disabled></button>';
      }

      // Day cells
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // WDA-909: Helper to format date as YYYY-MM-DD without timezone issues
      const toLocalDateString = (d: Date): string => {
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };

      for (let day = 1; day <= totalDays; day++) {
        const date = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), day);
        const dateStr = toLocalDateString(date);
        const isToday = date.getTime() === today.getTime();
        const isPast = date < today;
        const dateData = availableDates.get(dateStr);
        const isAvailable = dateData?.hasSlots === true;
        const isSelected = dateStr === this.state.selectedDate;

        // WDA-909: Determinar estado visual basado en slotCount
        const slotCount = dateData?.slotCount || 0;
        const isLowAvailability = isAvailable && slotCount > 0 && slotCount <= 2;

        const classes = ['calendar-day'];
        if (isToday) classes.push('today');
        if (isPast) classes.push('disabled');
        else if (isAvailable) {
          if (isLowAvailability) {
            classes.push('low-availability');
          } else {
            classes.push('available');
          }
        } else {
          classes.push('disabled');
        }
        if (isSelected) classes.push('selected');

        html += `
          <button
            type="button"
            class="${classes.join(' ')}"
            data-date="${dateStr}"
            ${isPast || !isAvailable ? 'disabled' : ''}
          >
            ${day}
          </button>
        `;
      }

      grid.innerHTML = html;

      // Bind click events to available days (both normal and low-availability)
      grid.querySelectorAll('.calendar-day.available, .calendar-day.low-availability').forEach((day) => {
        day.addEventListener('click', (e) => {
          const dateStr = (e.currentTarget as HTMLElement).dataset.date;
          if (dateStr) this.selectDate(dateStr);
        });
      });

      // Update navigation buttons
      const prevBtn = this.widget.querySelector('.prev-month') as HTMLButtonElement;
      const nextBtn = this.widget.querySelector('.next-month') as HTMLButtonElement;

      if (prevBtn) {
        const prevMonth = new Date(currentMonth.getFullYear(), currentMonth.getMonth() - 1);
        prevBtn.disabled = prevMonth < new Date(today.getFullYear(), today.getMonth());
      }
    }

    private navigateMonth(delta: number): void {
      this.state.currentMonth = new Date(
        this.state.currentMonth.getFullYear(),
        this.state.currentMonth.getMonth() + delta,
        1
      );
      this.renderCalendar();
    }

    private async selectDate(dateStr: string): Promise<void> {
      this.state.selectedDate = dateStr;
      this.renderCalendar(); // Update selection visual

      // Update selected date display
      const dateDisplay = this.widget.querySelector('.selected-date-display');
      if (dateDisplay) {
        dateDisplay.textContent = formatDate(dateStr, this.state.locale);
      }

      // Also update form summary
      const summaryDate = this.widget.querySelector('.selected-date-text');
      if (summaryDate) {
        summaryDate.textContent = formatDate(dateStr, this.state.locale);
      }

      // Load time slots
      await this.loadTimeSlots(dateStr);
      this.showStep('slots');
    }

    // =========================================
    // TIME SLOTS
    // =========================================

    private async loadTimeSlots(date: string): Promise<void> {
      const loading = this.widget.querySelector('.slots-loading');
      const container = this.widget.querySelector('.slots-container');
      const empty = this.widget.querySelector('.slots-empty');

      loading?.classList.remove('hidden');
      container?.classList.add('hidden');
      empty?.classList.add('hidden');

      try {
        const dayData = await getDaySlots({
          sessionId: this.state.sessionId,
          date,
        });

        if (!dayData || !dayData.slots || dayData.slots.length === 0) {
          empty?.classList.remove('hidden');
          this.state.daySlots = [];

          // WDA-1011: Clear container HTML to prevent stale slots from previous date
          // Root cause: Early return didn't clean DOM - users saw previous day's slots behind "No slots available"
          if (container) {
            container.innerHTML = '';
          }

          return;
        }

        this.state.daySlots = dayData.slots;
        this.state.maxCapacity = dayData.slots[0]?.capacity.maximum || 6;
        this.renderTimeSlots();
        container?.classList.remove('hidden');
      } catch (error) {
        console.error('[BookingWidget] Error loading slots:', error);
        empty?.classList.remove('hidden');

        // WDA-1011: Clear container HTML in error case too
        if (container) {
          container.innerHTML = '';
        }

        // WDA-1012 Frontend Workaround: Remove green dot from calendar day when getDaySlots fails
        // Backend inconsistency: getAvailableDates marks day as available but getDaySlots returns Error 500
        // This prevents users from clicking on broken days
        const calendarDay = this.widget.querySelector(`button[data-date="${date}"]`) as HTMLButtonElement;
        if (calendarDay) {
          calendarDay.classList.remove('available');
          calendarDay.disabled = true;
          console.warn(`[BookingWidget] WDA-1012: Removed 'available' class from ${date} due to getDaySlots error`);
        }
      } finally {
        loading?.classList.add('hidden');
      }
    }

    private renderTimeSlots(): void {
      const container = this.widget.querySelector('.slots-container');
      if (!container) return;

      const { daySlots, translations, sessionType, includedPersons } = this.state;

      // WDA-1002: Filter slots for pack sessions - need enough capacity for all included persons
      const minCapacityRequired = sessionType === 'pack' && includedPersons ? includedPersons : 1;

      // WDA-1004: For private sessions, only show slots with 100% availability
      const isPrivate = sessionType === 'private';

      let html = '';
      let hasAvailableSlots = false;
      let renderedSlotIndex = 0;

      daySlots.forEach((slot, originalIndex) => {
        const slotStatus = slot.status.toLowerCase();

        // WDA-1004: Skip slots that are not 100% available for private sessions
        if (isPrivate && slot.capacity.available !== slot.capacity.maximum) {
          return; // Skip this slot entirely - don't render it
        }

        // WDA-1002: For packs, also disable slots without enough capacity
        const insufficientCapacity = slot.capacity.available < minCapacityRequired;

        // A slot is disabled if not bookable OR if status is 'full' or 'closed' OR insufficient capacity for pack
        const isDisabled = !slot.bookable || slotStatus === 'full' || slotStatus === 'closed' || insufficientCapacity;
        const isSelected = this.state.selectedSlot?.startTime === slot.startTime;
        const capacityColor = getCapacityColor(slot.capacity);

        const classes = ['time-slot'];
        if (isDisabled) classes.push('disabled');
        if (isSelected) classes.push('selected');
        if (isPrivate) classes.push('private-slot'); // WDA-1004: Add visual distinction

        let capacityText = '';
        let capacityClass = '';

        if (slotStatus === 'full' || slot.capacity.available === 0) {
          capacityText = translations.full;
          capacityClass = 'full';
        } else if (slotStatus === 'closed') {
          capacityText = translations.closed;
          capacityClass = 'full';
        } else if (insufficientCapacity && sessionType === 'pack') {
          // WDA-1002: Show "insufficient capacity" for packs
          capacityText = (translations.insufficientForPack || 'Mín. {n} plazas').replace('{n}', String(minCapacityRequired));
          capacityClass = 'full';
        } else if (isPrivate) {
          // WDA-1004: For private sessions, show "Exclusive" instead of spots count
          hasAvailableSlots = true;
          capacityText = translations.privateExclusive || 'Uso exclusivo';
          capacityClass = 'private';
        } else {
          hasAvailableSlots = true;
          const spotWord = slot.capacity.available === 1 ? translations.spot : translations.spots;
          capacityText = `${slot.capacity.available} ${spotWord} ${translations.available}`;
          capacityClass = capacityColor === 'yellow' ? 'low' : '';
        }

        html += `
          <button
            type="button"
            class="${classes.join(' ')}"
            data-slot-index="${originalIndex}"
            ${isDisabled ? 'disabled' : ''}
          >
            <div class="slot-time">${formatTime(slot.startTime)}</div>
            <div class="slot-capacity ${capacityClass}">${capacityText}</div>
          </button>
        `;
        renderedSlotIndex++;
      });

      container.innerHTML = html;

      // Handle empty states for different session types
      const empty = this.widget.querySelector('.slots-empty');
      const emptyText = empty?.querySelector('.slots-empty-text');

      // WDA-1004: Show empty state if no private slots available
      if (isPrivate && !hasAvailableSlots && daySlots.length > 0) {
        if (emptyText) {
          emptyText.textContent = translations.noPrivateSlots || 'No hay horarios con disponibilidad exclusiva';
        }
        empty?.classList.remove('hidden');
        container.classList.add('hidden');
      }
      // WDA-1002: Show empty state if no slots available for pack
      else if (sessionType === 'pack' && !hasAvailableSlots && daySlots.length > 0) {
        if (emptyText) {
          emptyText.textContent = (translations.noPackSlots || 'No hay horarios con {n} plazas disponibles').replace('{n}', String(minCapacityRequired));
        }
        empty?.classList.remove('hidden');
        container.classList.add('hidden');
      } else {
        empty?.classList.add('hidden');
        container.classList.remove('hidden');
      }

      // Bind click events
      container.querySelectorAll('.time-slot:not(.disabled)').forEach((slot) => {
        slot.addEventListener('click', (e) => {
          const index = parseInt((e.currentTarget as HTMLElement).dataset.slotIndex || '0');
          this.selectSlot(index);
        });
      });
    }

    private selectSlot(index: number): void {
      const slot = this.state.daySlots[index];
      if (!slot) return;

      this.state.selectedSlot = slot;
      this.renderTimeSlots(); // Update selection visual

      // Update form summary
      const summarySlot = this.widget.querySelector('.selected-slot-text');
      if (summarySlot) {
        summarySlot.textContent = `${formatTime(slot.startTime)} - ${formatTime(slot.endTime)}`;
      }

      // WDA-909: Initialize attendees section with max capacity
      this.initAttendeesSection(slot.capacity.available);

      // WDA-1002: For pack sessions, initialize fixed attendees after base section
      if (this.state.sessionType === 'pack' && this.state.includedPersons) {
        this.initializePackAttendees(this.state.includedPersons);
      }

      // WDA-920: Show capacity warning and badge
      this.updateCapacityWarning(slot.capacity.available);
      this.updateCapacityBadge(slot.capacity.available);

      this.showStep('form');
    }

    // =========================================
    // WDA-920: CAPACITY WARNING & BADGE
    // =========================================

    private updateCapacityWarning(availableSpots: number): void {
      const warning = this.widget.querySelector('.capacity-warning');
      const warningText = this.widget.querySelector('.capacity-warning-text');
      const t = this.state.translations;

      if (availableSpots < 3 && availableSpots > 0) {
        if (warningText) {
          warningText.textContent = t.spotsRemaining.replace('{n}', String(availableSpots));
        }
        warning?.classList.remove('hidden');
      } else {
        warning?.classList.add('hidden');
      }
    }

    private updateCapacityBadge(availableSpots: number): void {
      const badge = this.widget.querySelector('.slot-capacity-badge');
      const badgeText = this.widget.querySelector('.capacity-badge-text');
      const t = this.state.translations;

      if (badgeText) {
        badgeText.textContent = t.spotsAvailableText.replace('{n}', String(availableSpots));
      }

      // Remove all color classes
      badge?.classList.remove('green', 'yellow', 'red');

      // Add appropriate color class
      if (availableSpots > 3) {
        badge?.classList.add('green');
      } else if (availableSpots >= 2) {
        badge?.classList.add('yellow');
      } else if (availableSpots === 1) {
        badge?.classList.add('red');
      }

      badge?.classList.remove('hidden');
    }

    // =========================================
    // FORM
    // =========================================

    // WDA-909: Initialize attendees section with max capacity
    private initAttendeesSection(maxAvailable: number): void {
      this.state.maxCapacity = maxAvailable;
      this.state.attendeeCount = 1;

      // WDA-911: Clear any existing additional attendees (keep only main contact)
      const list = this.widget.querySelector('.attendees-list');
      if (list) {
        const additionalAttendees = list.querySelectorAll('.attendee-row:not(.main-contact)');
        additionalAttendees.forEach(row => row.remove());
      }

      // Update max attendees display
      const maxEl = this.widget.querySelector('.max-attendees');
      if (maxEl) maxEl.textContent = String(maxAvailable);

      // Update count display
      this.updateAttendeesCount();

      // WDA-911: Bind add attendee button (only once using bound handler)
      const addBtn = this.widget.querySelector('[data-action="add-attendee"]') as HTMLButtonElement;
      if (addBtn) {
        // Remove any existing listener by cloning the button
        const newBtn = addBtn.cloneNode(true) as HTMLButtonElement;
        addBtn.parentNode?.replaceChild(newBtn, addBtn);
        newBtn.addEventListener('click', () => this.addAttendee());
      }

      // Update button state
      this.updateAddAttendeeButton();
    }

    // WDA-1002: Initialize fixed attendees for pack sessions
    private initializePackAttendees(includedPersons: number): void {
      const { translations, sessionType } = this.state;
      if (sessionType !== 'pack') return;

      // Set fixed capacity for packs
      this.state.maxCapacity = includedPersons;
      this.state.attendeeCount = 1; // Start with main contact

      const list = this.widget.querySelector('.attendees-list');
      if (!list) return;

      // Clear any existing additional attendees
      const additionalAttendees = list.querySelectorAll('.attendee-row:not(.main-contact)');
      additionalAttendees.forEach(row => row.remove());

      // Add remaining attendees (N-1 since main contact is already there)
      for (let i = 1; i < includedPersons; i++) {
        const row = document.createElement('div');
        row.className = 'attendee-row pack-attendee'; // Mark as pack attendee
        row.setAttribute('data-attendee-index', String(i));
        row.innerHTML = `
          <div class="attendee-header">
            <span class="attendee-number">${translations.attendeeData} ${i + 1}</span>
          </div>
          <div class="attendee-fields">
            <div class="attendee-field">
              <input
                type="text"
                name="attendee_name_${i}"
                placeholder="${translations.attendeeName}"
                required
                class="form-input attendee-name"
              />
            </div>
            <div class="attendee-field">
              <input
                type="email"
                name="attendee_email_${i}"
                placeholder="${translations.attendeeEmail}"
                class="form-input attendee-email"
              />
            </div>
          </div>
        `;
        list.appendChild(row);
        this.state.attendeeCount++;
      }

      // Update displays
      this.updateAttendeesCount();
      this.updateAddAttendeeButton();
      this.updateHiddenAttendeesField();

      // Hide add attendee button for packs (handled in updateAddAttendeeButton)
      console.log(`[BookingWidget] Pack initialized with ${includedPersons} attendees`);
    }

    private addAttendee(): void {
      if (this.state.attendeeCount >= this.state.maxCapacity) return;

      const { translations } = this.state;
      const index = this.state.attendeeCount;
      const list = this.widget.querySelector('.attendees-list');
      if (!list) return;

      const row = document.createElement('div');
      row.className = 'attendee-row';
      row.setAttribute('data-attendee-index', String(index));
      row.innerHTML = `
        <div class="attendee-actions">
          <button type="button" class="remove-attendee-btn" data-action="remove-attendee" data-index="${index}">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
            ${translations.removeAttendee}
          </button>
        </div>
        <div class="attendee-fields">
          <div class="attendee-field">
            <input
              type="text"
              name="attendee_name_${index}"
              placeholder="${translations.attendeeName}"
              required
              class="form-input attendee-name"
            />
          </div>
          <div class="attendee-field">
            <input
              type="email"
              name="attendee_email_${index}"
              placeholder="${translations.attendeeEmail}"
              class="form-input attendee-email"
            />
          </div>
        </div>
      `;

      list.appendChild(row);

      // Bind remove button
      const removeBtn = row.querySelector('[data-action="remove-attendee"]');
      removeBtn?.addEventListener('click', () => this.removeAttendee(index));

      this.state.attendeeCount++;
      this.updateAttendeesCount();
      this.updateAddAttendeeButton();
      this.updateHiddenAttendeesField();
      this.updateSubmitButton();

      // WDA-922: A11Y announcement
      const t = translations.a11y || translations;
      this.announce(t.attendeeAdded.replace('{n}', String(this.state.attendeeCount)));
    }

    private removeAttendee(index: number): void {
      const row = this.widget.querySelector(`.attendee-row[data-attendee-index="${index}"]`);
      if (row) {
        row.remove();
        this.state.attendeeCount--;
        this.updateAttendeesCount();
        this.updateAddAttendeeButton();
        this.updateHiddenAttendeesField();
        this.updateSubmitButton();

        // WDA-922: A11Y announcement
        const t = this.state.translations.a11y || this.state.translations;
        this.announce(t.attendeeRemoved);
      }
    }

    // =========================================
    // WDA-922: A11Y ANNOUNCEMENTS
    // =========================================

    private announce(message: string): void {
      const announcer = this.widget.querySelector(`#booking-announcements-${this.widget.id}`);
      if (announcer) {
        announcer.textContent = message;
        // Clear after announcement
        setTimeout(() => {
          announcer.textContent = '';
        }, 1000);
      }
    }

    private updateAttendeesCount(): void {
      const countEl = this.widget.querySelector('.attendees-count');
      if (countEl) {
        countEl.innerHTML = `${this.state.attendeeCount}/<span class="max-attendees">${this.state.maxCapacity}</span>`;
      }
      // WDA-1023: Update price summary when attendee count changes
      this.updatePriceSummary(appliedDiscount.get());
    }

    private updateAddAttendeeButton(): void {
      const addBtn = this.widget.querySelector('[data-action="add-attendee"]') as HTMLButtonElement;
      const addBtnContainer = this.widget.querySelector('.add-attendee-container');
      const hint = this.widget.querySelector('.add-attendee-disabled-hint');
      const t = this.state.translations;

      if (addBtn) {
        // WDA-1002: Hide add button entirely for pack sessions (fixed attendees)
        if (this.state.sessionType === 'pack') {
          addBtn.classList.add('hidden');
          addBtnContainer?.classList.add('hidden');
          hint?.classList.add('hidden');
          return;
        }

        // Show button for other session types
        addBtn.classList.remove('hidden');
        addBtnContainer?.classList.remove('hidden');

        const isDisabled = this.state.attendeeCount >= this.state.maxCapacity;
        addBtn.disabled = isDisabled;

        // WDA-920: Update tooltip with capacity message
        if (hint && isDisabled) {
          hint.textContent = t.capacityReached
            .replace('{current}', String(this.state.attendeeCount))
            .replace('{max}', String(this.state.maxCapacity));
          hint.classList.remove('hidden');
        } else {
          hint?.classList.add('hidden');
        }
      }
    }

    private updateHiddenAttendeesField(): void {
      const hidden = this.widget.querySelector('input[name="attendees"]') as HTMLInputElement;
      if (hidden) {
        hidden.value = String(this.state.attendeeCount);
      }
    }

    private updateSubmitButton(): void {
      const form = this.widget.querySelector('.booking-form') as HTMLFormElement;
      const submitBtn = form?.querySelector('.submit-button') as HTMLButtonElement;
      if (!form || !submitBtn) return;

      const emailInput = form.querySelector('input[name="customer_email"]') as HTMLInputElement;
      const privacyCheckbox = form.querySelector('input[name="privacy"]') as HTMLInputElement;
      const termsCheckbox = form.querySelector('input[name="terms"]') as HTMLInputElement;

      // WDA-909: Validate all attendee names are filled
      const attendeeNameInputs = form.querySelectorAll('.attendee-name') as NodeListOf<HTMLInputElement>;
      const allNamesValid = Array.from(attendeeNameInputs).every((input) => input.value.trim().length > 0);

      const isValid =
        allNamesValid &&
        emailInput?.value.trim().length > 0 &&
        privacyCheckbox?.checked &&
        termsCheckbox?.checked;

      submitBtn.disabled = !isValid;
    }

    private async handleSubmit(e: SubmitEvent): Promise<void> {
      e.preventDefault();

      const form = e.target as HTMLFormElement;
      const submitBtn = form.querySelector('.submit-button') as HTMLButtonElement;
      const errorMessage = form.querySelector('.form-message.error-message');
      const errorText = errorMessage?.querySelector('.error-text');

      // Validate
      if (!this.validateForm(form)) {
        return;
      }

      // Show loading
      submitBtn.disabled = true;
      submitBtn.classList.add('submitting');
      errorMessage?.classList.add('hidden');

      // Prepare data
      const formData = new FormData(form);

      // WDA-909: Collect all attendees data with required email and consents
      const attendeeRows = form.querySelectorAll('.attendee-row');
      const privacyChecked = (form.querySelector('input[name="privacy"]') as HTMLInputElement)?.checked || false;
      const customerEmail = formData.get('customer_email') as string;
      const attendees: Array<{ name: string; email: string; consents: { privacy: boolean; terms: boolean; health: boolean } }> = [];

      attendeeRows.forEach((row, index) => {
        const nameInput = row.querySelector(`input[name="attendee_name_${index}"]`) as HTMLInputElement;
        const emailInput = row.querySelector(`input[name="attendee_email_${index}"]`) as HTMLInputElement;
        if (nameInput?.value.trim()) {
          // For first attendee (primary contact), use main form email if attendee email empty
          const attendeeEmail = emailInput?.value.trim() || (index === 0 ? customerEmail : '');
          attendees.push({
            name: nameInput.value.trim(),
            email: attendeeEmail,
            consents: {
              privacy: privacyChecked,
              terms: privacyChecked, // Single checkbox implies acceptance of all terms
              health: privacyChecked, // Health declaration accepted with privacy checkbox
            },
          });
        }
      });

      // Main contact is the first attendee
      const mainContact = attendees[0] || { name: '', email: '' };

      // Build notes with all attendees info
      let notes = formData.get('notes') as string || '';
      if (attendees.length > 1) {
        const attendeesList = attendees
          .map((a, i) => `${i + 1}. ${a.name}${a.email ? ` (${a.email})` : ''}`)
          .join('\n');
        notes = notes
          ? `${notes}\n\n--- Asistentes ---\n${attendeesList}`
          : `--- Asistentes ---\n${attendeesList}`;
      }

      // WDA-941: Get language from current locale (uppercase for GraphQL)
      const language = this.state.locale.toUpperCase();

      // WDA-1003: Vouchers don't have date/slot selection - they are purchased for future redemption
      const isVoucherPurchase = this.state.sessionType === 'voucher';
      // WDA-1033: Gifts have their own purchase flow with recipient info
      const isGiftPurchase = this.state.sessionType === 'gift';

      // Backend requires date/time even for vouchers (since v1.5.0)
      // For vouchers, send placeholder values - the is_voucher_purchase flag tells backend not to reserve inventory
      const getPlaceholderDate = () => {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        return tomorrow.toISOString().split('T')[0]; // YYYY-MM-DD
      };

      // WDA-1033: Handle gift purchase separately
      if (isGiftPurchase) {
        const recipientName = formData.get('recipient_name') as string;
        const recipientEmail = formData.get('recipient_email') as string;
        const giftMessage = formData.get('gift_message') as string || undefined;
        const buyerNotes = formData.get('notes') as string || undefined;

        // Get delivery option (immediate, scheduled, no_send)
        const deliveryOptionValue = formData.get('delivery_option') as string;
        // Map 'now' to 'immediate' for backward compatibility, keep others as-is
        const deliveryOption = (deliveryOptionValue === 'now' ? 'immediate' : deliveryOptionValue) as DeliveryOption;

        // Only get date/time if scheduled
        const deliveryDate = deliveryOption === 'scheduled'
          ? (formData.get('delivery_date') as string || undefined)
          : undefined;
        const deliveryTime = deliveryOption === 'scheduled'
          ? (formData.get('delivery_time') as string || undefined)
          : undefined;

        // WDA-1034: Clean gift purchase data for dedicated endpoint
        const giftData = {
          session_id: this.state.sessionId,
          customer_name: formData.get('customer_name') as string,
          customer_email: formData.get('customer_email') as string,
          customer_phone: formData.get('customer_phone') as string || undefined,
          recipient: {
            name: recipientName,
            email: recipientEmail,
          },
          gift_message: giftMessage,
          buyer_notes: buyerNotes,
          delivery_option: deliveryOption,
          delivery_date: deliveryDate,
          delivery_time: deliveryTime,
          language: language,
          consents: {
            privacy: true,
            terms: true,
          },
        };

        try {
          // WDA-1034: Use dedicated /gifts/purchase endpoint
          const { purchaseGift } = await import('../../lib/booking/api');
          const result = await purchaseGift(giftData);

          if (result.success) {
            this.showGiftConfirmation(result);
          } else {
            if (errorText) {
              errorText.textContent = this.translateError(result.error || '');
            }
            errorMessage?.classList.remove('hidden');
          }
        } catch (error) {
          console.error('[BookingWidget] Gift purchase error:', error);
          if (errorText) {
            errorText.textContent = this.state.translations.errorGeneric;
          }
          errorMessage?.classList.remove('hidden');
        } finally {
          submitBtn.disabled = false;
          submitBtn.classList.remove('submitting');
        }
        return;
      }

      // WDA-1023: Get discount code if applied (from appliedDiscount, not the input field)
      const currentDiscount = appliedDiscount.get();
      const discountCode = currentDiscount?.code || undefined;

      const bookingData: CreateBookingRequest = {
        session_id: this.state.sessionId,
        // For vouchers: placeholder date/time (actual redemption date chosen later)
        slot_date: isVoucherPurchase ? getPlaceholderDate() : this.state.selectedDate!,
        slot_time: isVoucherPurchase ? '10:00' : formatTime(this.state.selectedSlot!.startTime),
        attendees: attendees,
        customer_name: mainContact.name,
        customer_email: formData.get('customer_email') as string,
        customer_phone: formData.get('customer_phone') as string || undefined,
        notes: notes || undefined,
        language: language, // WDA-941: ES, CA, EN, FR
        // WDA-1003: Mark as voucher purchase for backend to generate voucher codes
        is_voucher_purchase: isVoucherPurchase,
        // WDA-1023: Include discount code if validated
        discount_code: discountCode,
      };

      try {
        const result = await createBooking(bookingData);

        if (result.success) {
          // WDA-1023: Clear discount after successful booking
          clearDiscount();
          this.showConfirmation(result);
        } else {
          // WDA-921: Check for rate limit error
          if (this.isRateLimitError(result.error || '')) {
            this.handleRateLimit();
          }

          if (errorText) {
            // WDA-912: Translate backend error messages to current locale
            errorText.textContent = this.translateError(result.error || '');
          }
          errorMessage?.classList.remove('hidden');
        }
      } catch (error) {
        console.error('[BookingWidget] Submit error:', error);

        // WDA-921: Check if error is rate limit related
        const errorMsg = (error as Error).message || '';
        if (this.isRateLimitError(errorMsg)) {
          this.handleRateLimit();
        }

        if (errorText) {
          errorText.textContent = this.state.translations.errorGeneric;
        }
        errorMessage?.classList.remove('hidden');
      } finally {
        submitBtn.disabled = false;
        submitBtn.classList.remove('submitting');
      }
    }

    // =========================================
    // WDA-921: RATE LIMITING
    // =========================================

    private isRateLimitError(errorMessage: string): boolean {
      return /rate.?limit|too many.*(?:attempts|booking|requests)|429/i.test(errorMessage);
    }

    private handleRateLimit(): void {
      // Backend bloquea por 15 minutos (900 segundos)
      this.state.rateLimitUntil = Date.now() + (15 * 60 * 1000);
      this.state.rateLimitCountdown = 900;
      this.startRateLimitCountdown();
      this.disableSubmitButton();
    }

    private startRateLimitCountdown(): void {
      const countdownInterval = setInterval(() => {
        if (!this.state.rateLimitUntil) {
          clearInterval(countdownInterval);
          return;
        }

        const remaining = Math.ceil((this.state.rateLimitUntil - Date.now()) / 1000);

        if (remaining <= 0) {
          clearInterval(countdownInterval);
          this.state.rateLimitUntil = null;
          this.state.rateLimitCountdown = 0;
          this.enableSubmitButton();
          this.updateRateLimitDisplay();
        } else {
          this.state.rateLimitCountdown = remaining;
          this.updateRateLimitDisplay();
        }
      }, 1000);
    }

    private updateRateLimitDisplay(): void {
      const display = this.widget.querySelector('.rate-limit-message');
      if (!display) return;

      if (this.state.rateLimitCountdown > 0) {
        const minutes = Math.floor(this.state.rateLimitCountdown / 60);
        const seconds = this.state.rateLimitCountdown % 60;
        const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;

        const t = this.state.translations;
        display.textContent = t.rateLimitMessage.replace('{time}', timeStr);
        display.classList.remove('hidden');
      } else {
        display.classList.add('hidden');
      }
    }

    private disableSubmitButton(): void {
      const submitBtn = this.widget.querySelector('.submit-button') as HTMLButtonElement;
      if (submitBtn) {
        submitBtn.disabled = true;
      }
    }

    private enableSubmitButton(): void {
      const submitBtn = this.widget.querySelector('.submit-button') as HTMLButtonElement;
      if (submitBtn) {
        submitBtn.disabled = false;
      }
      // Re-validate to ensure button state is correct
      this.updateSubmitButton();
    }

    private validateForm(form: HTMLFormElement): boolean {
      let isValid = true;
      const { translations } = this.state;

      // Reset errors
      form.querySelectorAll('.form-error').forEach((el) => el.classList.add('hidden'));
      form.querySelectorAll('.form-input, .form-select').forEach((el) => el.classList.remove('error'));

      // WDA-909: Validate all attendee names
      const attendeeNameInputs = form.querySelectorAll('.attendee-name') as NodeListOf<HTMLInputElement>;
      attendeeNameInputs.forEach((input) => {
        if (!input.value.trim()) {
          input.classList.add('error');
          isValid = false;
        }
      });

      if (!isValid) {
        const attendeesError = form.querySelector('.attendees-error');
        attendeesError?.classList.remove('hidden');
      }

      // Email (main contact)
      const emailInput = form.querySelector('input[name="customer_email"]') as HTMLInputElement;
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailInput?.value.trim()) {
        this.showFieldError(emailInput, translations.emailRequired);
        isValid = false;
      } else if (!emailRegex.test(emailInput.value)) {
        this.showFieldError(emailInput, translations.emailInvalid);
        isValid = false;
      }

      // WDA-1033: Gift recipient validation
      if (this.state.sessionType === 'gift') {
        const recipientNameInput = form.querySelector('input[name="recipient_name"]') as HTMLInputElement;
        const recipientEmailInput = form.querySelector('input[name="recipient_email"]') as HTMLInputElement;

        if (!recipientNameInput?.value.trim()) {
          this.showFieldError(recipientNameInput, translations.giftRecipientNameRequired);
          isValid = false;
        }

        if (!recipientEmailInput?.value.trim()) {
          this.showFieldError(recipientEmailInput, translations.giftRecipientEmailRequired);
          isValid = false;
        } else if (!emailRegex.test(recipientEmailInput.value)) {
          this.showFieldError(recipientEmailInput, translations.emailInvalid);
          isValid = false;
        }
      }

      // Privacy
      const privacyCheckbox = form.querySelector('input[name="privacy"]') as HTMLInputElement;
      if (!privacyCheckbox?.checked) {
        const privacyError = privacyCheckbox?.closest('.form-group')?.querySelector('.form-error');
        privacyError?.classList.remove('hidden');
        isValid = false;
      }

      // Terms (Safety & Booking Conditions)
      const termsCheckbox = form.querySelector('input[name="terms"]') as HTMLInputElement;
      if (!termsCheckbox?.checked) {
        const termsError = termsCheckbox?.closest('.form-group')?.querySelector('.form-error');
        termsError?.classList.remove('hidden');
        isValid = false;
      }

      return isValid;
    }

    private showFieldError(input: HTMLInputElement | null, message: string): void {
      if (!input) return;
      input.classList.add('error');
      const errorEl = input.closest('.form-group')?.querySelector('.form-error');
      if (errorEl) {
        errorEl.textContent = message;
        errorEl.classList.remove('hidden');
      }
    }

    // WDA-912: Translate backend error messages to current locale
    private translateError(errorMessage: string): string {
      const { translations } = this.state;

      // Pattern: "Only X spots available" -> errorSpotsLimit
      const spotsMatch = errorMessage.match(/Only (\d+) spots? available/i);
      if (spotsMatch) {
        return translations.errorSpotsLimit.replace('{n}', spotsMatch[1]);
      }

      // Pattern: "Attendee X: email is required" -> errorEmailRequired
      const emailMatch = errorMessage.match(/Attendee (\d+):?\s*email\s*(?:is\s*)?required/i);
      if (emailMatch) {
        return translations.errorEmailRequired.replace('{n}', emailMatch[1]);
      }

      // Pattern: rate limit / too many attempts
      if (/too many.*(?:attempts|booking|requests)|rate.?limit/i.test(errorMessage)) {
        return translations.errorRateLimit;
      }

      // Pattern: slot is full
      if (/slot.*full|full.*slot|no.*spots/i.test(errorMessage)) {
        return translations.errorSlotFull;
      }

      // Pattern: slot is closed/unavailable
      if (/slot.*closed|closed.*slot|unavailable/i.test(errorMessage)) {
        return translations.errorSlotClosed;
      }

      // Pattern: invalid date
      if (/invalid.*date|date.*invalid/i.test(errorMessage)) {
        return translations.errorInvalidDate;
      }

      // Pattern: session expired
      if (/session.*expired|expired.*session/i.test(errorMessage)) {
        return translations.errorSessionExpired;
      }

      // Fallback: return original message or generic error
      return errorMessage || translations.errorGeneric;
    }

    // =========================================
    // CONFIRMATION
    // =========================================

    // WDA-1003: Extended to support voucher_codes
    private showConfirmation(result: { booking_number?: string; success: boolean; voucher_codes?: string[] }): void {
      const successEl = this.widget.querySelector('.confirmation-success');
      const errorEl = this.widget.querySelector('.confirmation-error');
      const { sessionType, translations } = this.state;

      if (result.success) {
        const isVoucher = sessionType === 'voucher';

        // Update titles for voucher purchases
        const successTitle = this.widget.querySelector('.success-title');
        const successMessage = this.widget.querySelector('.success-message');
        if (isVoucher && successTitle && successMessage) {
          successTitle.textContent = translations.voucherSuccessTitle;
          successMessage.textContent = translations.voucherSuccessMessage;
        }

        // Show/hide appropriate sections based on session type
        const regularDetails = this.widget.querySelector('.booking-details--regular');
        const voucherSection = this.widget.querySelector('.voucher-codes-section');

        if (isVoucher && result.voucher_codes?.length) {
          // Hide regular booking details for vouchers (no date/time)
          regularDetails?.classList.add('hidden');

          // Show voucher codes
          const codesList = this.widget.querySelector('.voucher-codes-list');
          if (codesList && result.voucher_codes) {
            codesList.innerHTML = result.voucher_codes.map(code => `
              <div class="voucher-code-item">
                <code class="voucher-code">${code}</code>
                <button type="button" class="copy-code-btn" data-code="${code}" aria-label="Copiar código">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                </button>
              </div>
            `).join('');

            // Add copy functionality
            codesList.querySelectorAll('.copy-code-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                const code = (btn as HTMLButtonElement).dataset.code;
                if (code) {
                  navigator.clipboard.writeText(code).then(() => {
                    btn.classList.add('copied');
                    setTimeout(() => btn.classList.remove('copied'), 2000);
                  });
                }
              });
            });
          }
          voucherSection?.classList.remove('hidden');
        } else {
          // Regular booking - show date/time details
          regularDetails?.classList.remove('hidden');
          voucherSection?.classList.add('hidden');

          const bookingNumber = this.widget.querySelector('.booking-number');
          const confirmedDate = this.widget.querySelector('.confirmed-date');
          const confirmedTime = this.widget.querySelector('.confirmed-time');
          const confirmedAttendees = this.widget.querySelector('.confirmed-attendees');

          if (bookingNumber) {
            bookingNumber.textContent = result.booking_number || '-';
          }
          if (confirmedDate && this.state.selectedDate) {
            confirmedDate.textContent = formatDate(this.state.selectedDate, this.state.locale);
          }
          if (confirmedTime && this.state.selectedSlot) {
            confirmedTime.textContent = `${formatTime(this.state.selectedSlot.startTime)} - ${formatTime(this.state.selectedSlot.endTime)}`;
          }
          if (confirmedAttendees) {
            confirmedAttendees.textContent = String(this.state.attendeeCount);
          }
        }

        successEl?.classList.remove('hidden');
        errorEl?.classList.add('hidden');
      } else {
        successEl?.classList.add('hidden');
        errorEl?.classList.remove('hidden');
      }

      this.showStep('confirmation');
    }

    // WDA-1033: Gift purchase confirmation
    private showGiftConfirmation(result: { success: boolean; gift_code?: string; error?: string }): void {
      const successEl = this.widget.querySelector('.confirmation-success');
      const errorEl = this.widget.querySelector('.confirmation-error');
      const { translations } = this.state;

      if (result.success && result.gift_code) {
        // Update titles for gift purchases
        const successTitle = this.widget.querySelector('.success-title');
        const successMessage = this.widget.querySelector('.success-message');
        if (successTitle && successMessage) {
          successTitle.textContent = translations.giftSuccessTitle;
          successMessage.textContent = translations.giftSuccessMessage;
        }

        // Hide regular booking details
        const regularDetails = this.widget.querySelector('.booking-details--regular');
        const voucherSection = this.widget.querySelector('.voucher-codes-section');
        regularDetails?.classList.add('hidden');
        voucherSection?.classList.add('hidden');

        // Show gift code section
        const giftSection = this.widget.querySelector('.gift-code-section');
        const giftCodeEl = this.widget.querySelector('.gift-code');
        if (giftCodeEl) {
          giftCodeEl.textContent = result.gift_code;
        }
        giftSection?.classList.remove('hidden');

        successEl?.classList.remove('hidden');
        errorEl?.classList.add('hidden');
      } else {
        successEl?.classList.add('hidden');
        errorEl?.classList.remove('hidden');
      }

      this.showStep('confirmation');
    }

    // =========================================
    // NAVIGATION
    // =========================================

    private showStep(step: 'calendar' | 'slots' | 'form' | 'confirmation'): void {
      // Hide all steps
      this.widget.querySelectorAll('.booking-step').forEach((el) => {
        el.classList.add('hidden');
      });

      // Show target step
      const targetStep = this.widget.querySelector(`.booking-step[data-step="${step}"]`);
      targetStep?.classList.remove('hidden');

      // Update progress
      const steps = ['calendar', 'slots', 'form', 'confirmation'];
      const currentIndex = steps.indexOf(step);

      this.widget.querySelectorAll('.progress-step').forEach((el, i) => {
        el.classList.remove('active', 'completed');
        // WDA-922: Update aria-current
        el.removeAttribute('aria-current');
        if (i < currentIndex) {
          el.classList.add('completed');
        } else if (i === currentIndex) {
          el.classList.add('active');
          el.setAttribute('aria-current', 'step');
        }
      });

      // WDA-922: Focus management
      setTimeout(() => {
        if (targetStep) {
          const focusable = targetStep.querySelector('input, button:not([disabled]), select, textarea') as HTMLElement;
          focusable?.focus();
        }
      }, 100);
    }

    // =========================================
    // WDA-1023: DISCOUNT CODE INTEGRATION
    // =========================================

    private subscribeToDiscountStore(): void {
      // Subscribe to discount store changes
      appliedDiscount.subscribe((discount) => {
        this.updatePriceSummary(discount);
      });
    }

    private updatePriceSummary(discount: Discount | null): void {
      const priceSummary = this.widget.querySelector('[data-price-summary]');
      if (!priceSummary) return;

      const originalPriceEl = priceSummary.querySelector('[data-original-price]');
      const discountRow = priceSummary.querySelector('[data-discount-row]');
      const discountAmountEl = priceSummary.querySelector('[data-discount-amount]');
      const finalPriceEl = priceSummary.querySelector('[data-final-price]');

      // Get base price: session price * attendee count
      const basePrice = this.state.sessionPrice * Math.max(1, this.state.attendeeCount);

      // Format currency
      const formatCurrency = (amount: number) => `${amount.toFixed(2)} €`;

      // Update original price
      if (originalPriceEl) {
        originalPriceEl.textContent = formatCurrency(basePrice);
      }

      // Handle discount
      if (discount && discount.code) {
        const discountAmount = discount.type === 'percentage'
          ? (basePrice * discount.amount / 100)
          : Math.min(discount.amount, basePrice);
        const finalPrice = basePrice - discountAmount;

        // Show discount row
        discountRow?.classList.remove('hidden');

        // Update discount amount with label
        if (discountAmountEl) {
          const discountLabel = discount.type === 'percentage'
            ? `-${discount.amount}%`
            : `-${formatCurrency(discount.amount)}`;
          discountAmountEl.textContent = `${discountLabel} (${formatCurrency(discountAmount)})`;
        }

        // Update final price
        if (finalPriceEl) {
          finalPriceEl.textContent = formatCurrency(finalPrice);
        }
      } else {
        // Hide discount row, show base price as total
        discountRow?.classList.add('hidden');
        if (finalPriceEl) {
          finalPriceEl.textContent = formatCurrency(basePrice);
        }
      }
    }

    private resetWidget(): void {
      // Reset state
      this.state.selectedDate = null;
      this.state.daySlots = [];
      this.state.selectedSlot = null;

      // WDA-1023: Clear any applied discount
      clearDiscount();

      // Reset form
      const form = this.widget.querySelector('.booking-form') as HTMLFormElement;
      form?.reset();

      // Reset confirmation
      const successEl = this.widget.querySelector('.confirmation-success');
      const errorEl = this.widget.querySelector('.confirmation-error');
      successEl?.classList.remove('hidden');
      errorEl?.classList.add('hidden');

      // Go back to calendar
      this.showStep('calendar');
      this.renderCalendar();
    }
  }

  // Initialize all booking widgets on the page
  function initBookingWidgets(): void {
    const widgets = document.querySelectorAll('.booking-widget');
    widgets.forEach((widget) => {
      new BookingWidgetController(widget as HTMLElement);
    });
  }

  // Initialize on DOM load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initBookingWidgets);
  } else {
    initBookingWidgets();
  }
</script>
